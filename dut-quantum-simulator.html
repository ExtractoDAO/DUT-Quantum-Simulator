<!DOCTYPE html>
<html lang="en-US">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DUT Quantum Simulator 5.0: ExtractoDAO™ S/A – Blockchain and Advanced Scientific Research - Copyright ©2025</title>
    <style>
        /* Module: Global CSS Styles and Theme Variables */
        :root {
            --bg-color-start: #0a0e17;
            --bg-color-end: #0d1117;
            --container-bg: rgba(22, 27, 34, 0.85);
            --container-border: #2b3a4d;
            --panel-bg: rgba(26, 32, 44, 0.7);
            --panel-border: #364152;
            --text-color-primary: #e2e8f0;
            --text-color-secondary: #a0acc0;
            --highlight-color: #63b3ed;
            --gradient-blue-start: #63b3ed;
            --gradient-blue-end: #00c6fb;
            --button-gradient-start: #4299e1;
            --button-gradient-end: #3182ce;
            --slider-track-start: #2d3748;
            --slider-track-end: #4a5568;
            --info-box-border: #63b3ed;
            --equation-bg: rgba(0, 0, 0, 0.4);
            --canvas-bg-start: #0a0e17;
            --canvas-bg-end: #05070a;
            --grid-color: rgba(74, 85, 104, 0.4);
            --axis-color: #4a5568;
            --results-text-color: #00d9ff;
            --message-info-start: #2c5282;
            --message-info-end: #1a365d;
            --message-error-start: #c53030;
            --message-error-end: #9b2c2c;
            --input-bg: #1c2333;
            --input-border: #364152;
            --warning-color: #d69e2e; /* For consistency check warnings */
        }
        body {
            font-family: 'Segoe UI', Tahoma, sans-serif;
            background: linear-gradient(135deg, var(--bg-color-start) 0%, var(--bg-color-end) 100%);
            color: var(--text-color-primary);
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            padding: 1rem;
            margin: 0;
            overflow-x: hidden;
            box-sizing: border-box;
        }
        .container {
            background: var(--container-bg);
            border: 1px solid var(--container-border);
            border-radius: 16px;
            padding: 2rem;
            margin: 1rem auto 3rem;
            width: 95%;
            max-width: 1200px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(4px);
        }
        h1 {
            font-size: 2.2rem;
            font-weight: 700;
            text-align: center;
            margin: 0.5rem 0 1.5rem;
            background: linear-gradient(90deg, var(--gradient-blue-start) 0%, var(--gradient-blue-end) 100%);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        .subtitle {
            text-align: center;
            color: var(--text-color-secondary);
            font-size: 1.1rem;
            margin-bottom: 2rem;
            line-height: 1.6;
        }
        .grid-layout {
            display: grid;
            grid-template-columns: 1fr;
            gap: 2rem;
        }
        @media (min-width: 992px) {
            .grid-layout {
                grid-template-columns: 1fr 1.5fr;
            }
        }
        .panel {
            background: var(--panel-bg);
            border: 1px solid var(--panel-border);
            border-radius: 12px;
            padding: 1.8rem;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }
        .controls {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 1rem;
            margin-bottom: 1.8rem;
        }
        button {
            background: linear-gradient(135deg, var(--button-gradient-start) 0%, var(--button-gradient-end) 100%);
            color: white;
            padding: 0.9rem 1.8rem;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            text-align: center;
        }
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 8px rgba(0, 0, 0, 0.15);
        }
        button.active {
            background: linear-gradient(135deg, var(--highlight-color) 0%, var(--button-gradient-start) 100%);
            box-shadow: 0 0 15px rgba(99, 179, 237, 0.4);
        }
        .slider-group, .input-group {
            margin-bottom: 1.5rem;
        }
        .slider-header, .input-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.8rem;
            font-size: 1rem;
            color: var(--text-color-primary);
        }
        input[type="range"] {
            width: 100%;
            height: 10px;
            background: linear-gradient(90deg, var(--slider-track-start) 0%, var(--slider-track-end) 100%);
            border-radius: 5px;
            -webkit-appearance: none;
            outline: none;
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.3);
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 22px;
            height: 22px;
            border-radius: 50%;
            background: var(--highlight-color);
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }
        input[type="range"]::-moz-range-thumb {
            width: 22px;
            height: 22px;
            border-radius: 50%;
            background: var(--highlight-color);
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }
        input[type="number"], input[type="text"], textarea, select { /* Added select for consistency */
            width: 100%;
            padding: 0.7rem 1rem;
            border-radius: 5px;
            border: 1px solid var(--input-border);
            background-color: var(--input-bg);
            color: var(--text-color-primary);
            font-size: 1rem;
            box-sizing: border-box;
        }
        .info-box {
            background: var(--panel-bg);
            border-left: 4px solid var(--info-box-border);
            padding: 1.5rem;
            border-radius: 8px;
            margin-top: 2rem;
            font-size: 1rem;
            line-height: 1.7;
            display: none; /* Hidden by default, shown by JS */
        }
        .info-box.active {
            display: block;
        }
        .equation {
            font-family: 'Courier New', monospace;
            background: var(--equation-bg);
            padding: 1rem;
            border-radius: 6px;
            margin: 1rem 0;
            text-align: center;
            font-size: 1.3rem;
            color: var(--highlight-color);
            border: 1px solid var(--container-border);
            overflow-x: auto; /* Allows horizontal scrolling on small screens */
        }
        canvas {
            background: radial-gradient(ellipse at center, var(--canvas-bg-start) 0%, var(--canvas-bg-end) 100%);
            border: 1px solid var(--container-border);
            border-radius: 12px;
            width: 100%;
            height: 500px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
        }
        .results-box {
            background: var(--panel-bg);
            border: 1px solid var(--panel-border);
            border-radius: 8px;
            padding: 1.5rem;
            margin-top: 1.5rem;
            display: none; /* Hidden by default, shown by JS */
        }
        .results-box.active {
            display: block;
        }
        .results-box h2 {
            font-size: 1.1rem;
            font-weight: bold;
            margin-bottom: 0.75rem;
            color: var(--highlight-color);
        }
        .results-box .results-content {
            font-size: 0.95rem;
            line-height: 1.7;
            color: var(--results-text-color);
        }
        .message-box {
            display: none;
            margin-top: 1rem;
            padding: 0.75rem;
            border-radius: 4px;
            font-size: 0.85rem;
            text-align: center;
        }
        .message-box.info {
            background: linear-gradient(90deg, var(--message-info-start), var(--message-info-end));
            color: white;
        }
        .message-box.error {
            background: linear-gradient(90deg, var(--message-error-start), var(--message-error-end));
            color: white;
        }
        .message-box.warning {
            background: linear-gradient(90deg, var(--warning-color), #a06e1e);
            color: white;
        }
        .hidden {
            display: none !important;
        }
        /* Styles for Local Ledger Section */
        #localLedgerSection {
            background: var(--panel-bg);
            border: 1px solid var(--panel-border);
            border-radius: 12px;
            padding: 1.8rem;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            margin-top: 2rem;
        }
        #localLedgerControls, #consistencyCheckControls, #aiAssistantControls {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 1rem;
            margin-bottom: 1.8rem;
        }
        #localLedgerStatus {
            font-size: 0.95rem;
            color: var(--text-color-secondary);
            margin-top: 1rem;
            white-space: pre-wrap; /* Preserve whitespace and line breaks */
            word-wrap: break-word; /* Break long words */
            max-height: 200px;
            overflow-y: auto;
            padding: 0.5rem;
            border: 1px dashed var(--panel-border);
            border-radius: 8px;
        }
        #privacySelector {
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 1rem;
            gap: 0.5rem;
        }
        #privacySelector label {
            color: var(--text-color-primary);
            font-size: 0.95rem;
        }
        #privacySelector select {
            background-color: var(--input-bg);
            border: 1px solid var(--input-border);
            color: var(--text-color-primary);
            padding: 0.5rem;
            border-radius: 5px;
            font-size: 0.9rem;
        }
        /* New styles for input validation */
        .input-error {
            border: 2px solid var(--message-error-start) !important;
        }
        .error-message {
            color: var(--message-error-start);
            font-size: 0.8rem;
            margin-top: 0.5rem;
            display: block; /* Ensures it takes its own line */
        }
        #observationalDataPanel {
            margin-top: 2rem;
        }
        #observationalDataDisplay {
            background: var(--input-bg);
            border: 1px solid var(--input-border);
            padding: 1rem;
            border-radius: 8px;
            max-height: 300px;
            overflow-y: auto;
            white-space: pre-wrap;
            font-size: 0.9rem;
            color: var(--text-color-secondary);
        }
        #aiAssistantPanel {
            margin-top: 2rem;
            background: var(--panel-bg);
            border: 1px solid var(--panel-border);
            border-radius: 12px;
            padding: 1.8rem;
            box-shadow: 0 44px 12px rgba(0, 0, 0, 0.15);
        }
        #aiAssistantOutput {
            background: var(--input-bg);
            border: 1px solid var(--input-border);
            padding: 1rem;
            border-radius: 8px;
            min-height: 80px;
            max-height: 200px;
            overflow-y: auto;
            white-space: pre-wrap;
            font-size: 0.9rem;
            color: var(--text-color-secondary);
        }
        /* Style for the new Interactive Console */
        #interactiveConsolePanel {
            margin-top: 2rem;
            background: var(--panel-bg);
            border: 1px solid var(--panel-border);
            border-radius: 12px;
            padding: 1.8rem;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }
        #consoleOutput {
            background: var(--input-bg);
            border: 1px solid var(--input-border);
            padding: 1rem;
            border-radius: 8px;
            height: 250px; /* Increased height for better visibility */
            overflow-y: auto;
            white-space: pre-wrap;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            color: var(--text-color-primary);
            margin-bottom: 1rem;
        }
        #consoleInput {
            width: calc(100% - 70px); /* Adjust for padding and button width */
            margin-right: 10px;
            vertical-align: middle;
        }
        #consoleInputBtn {
            padding: 0.7rem 1rem; /* Smaller padding for consistency */
            vertical-align: middle;
            width: 60px; /* Fixed width for consistency */
        }

        /* Styles for the new Advanced Modules */
        .advanced-module-panel {
            margin-top: 2rem;
            background: var(--panel-bg);
            border: 1px solid var(--panel-border);
            border-radius: 12px;
            padding: 1.8rem;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }
        .advanced-module-panel h2 {
            font-size: 1.3rem;
            font-weight: bold;
            margin-bottom: 1rem;
            color: var(--highlight-color);
        }
        .advanced-module-panel label {
            display: block;
            margin-bottom: 0.8rem;
            color: var(--text-color-primary);
            font-size: 1rem;
        }
        .advanced-module-panel input[type="number"],
        .advanced-module-panel select,
        .advanced-module-panel textarea { /* Added textarea for consistency */
            width: calc(100% - 20px); /* Adjust for padding */
            padding: 0.7rem 1rem;
            border-radius: 5px;
            border: 1px solid var(--input-border);
            background-color: var(--input-bg);
            color: var(--text-color-primary);
            font-size: 1rem;
            box-sizing: border-box;
            margin-top: 0.5rem;
        }
        .advanced-module-panel button {
            margin-top: 1rem;
            margin-right: 1rem;
        }
        .advanced-module-panel canvas {
            background: var(--input-bg); /* Darker background for consistency */
            border: 1px solid var(--input-border);
            border-radius: 8px;
            width: 100%;
            height: 200px; /* Fixed height for consistency */
            margin-top: 1rem;
        }
        .advanced-module-panel pre {
            background: var(--input-bg);
            border: 1px solid var(--input-border);
            padding: 1rem;
            border-radius: 8px;
            min-height: 50px;
            overflow-y: auto;
            white-space: pre-wrap;
            font-size: 0.9rem;
            color: var(--text-color-secondary);
            margin-top: 1rem;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>DUT Universal Simulator v6.0: Advanced Cosmic Dynamics & Meta-Checks</h1>
        <div class="controls">
            <button id="modePotentialBtn" class="active">Gravitational Potential</button>
            <button id="modeFossilBtn">Cosmic Fossil Record</button>
            <button id="modeGalacticBtn">Galactic Evolution</button>
            <button id="modeRetractionBtn">Thermodynamic Retraction</button>
        </div>
        <div class="grid-layout">
            <div>
                <div id="potentialControls" class="panel">
                    <h2 style="font-size: 1.3rem; font-weight: bold; margin-bottom: 1rem; color: var(--highlight-color);">Gravitational Potential Parameters</h2>
                    <div class="controls">
                        <button id="mode1D" class="active">1D Visualization</button>
                        <button id="animateBtn">Animate</button>
                        <button id="resetBtn">Reset</button>
                        <button id="exportPotentialCSVBtn">Export Results (CSV)</button>
                    </div>

                    <div class="slider-group">
                        <div class="slider-header">
                            <span>Amplitude (V₀)</span>
                            <span id="amplitudeValue">1.0</span>
                        </div>
                        <input type="range" id="amplitude" min="0.1" max="2" step="0.1" value="1">
                    </div>

                    <div class="slider-group">
                        <div class="slider-header">
                            <span>Frequency ($\omega$)</span>
                            <span id="frequencyValue">3.0</span>
                        </div>
                        <input type="range" id="frequency" min="0.5" max="10" step="0.5" value="3">
                    </div>

                    <div class="slider-group">
                        <div class="slider-header">
                            <span>Decay ($\alpha$)</span>
                            <span id="decayValue">0.10</span>
                        </div>
                        <input type="range" id="decay" min="0.01" max="0.5" step="0.01" value="0.1">
                    </div>

                    <div class="slider-group">
                        <div class="slider-header">
                            <span>Central Potential ($\beta$)</span>
                            <span id="centralValue">-1.0</span>
                        </div>
                        <input type="range" id="central" min="-2" max="0" step="0.1" value="-1">
                    </div>
                    <div class="slider-group">
                        <div class="slider-header">
                            <span>Core Size Factor ($R_{core}$ x 10<sup>28</sup> m)</span>
                            <span id="radiusVal">1.0</span>
                        </div>
                        <input type="range" id="radius" min="0.1" max="10" step="0.1" value="1.0">
                    </div>

                    <div class="slider-group">
                        <div class="slider-header">
                            <span>Central Density Factor ($\rho_0$ x 10<sup>-26</sup> kg/m³)</span>
                            <span id="densityVal">5.0</span>
                        </div>
                        <input type="range" id="density" min="1" max="10" step="1" value="5.0">
                    </div>
                    <div class="slider-group">
                        <div class="slider-header">
                            <span>Simulation Time (t, Gyr)</span>
                            <span id="simTimeVal">0.0</span>
                        </div>
                        <input type="range" id="simTime" min="0" max="100" step="0.1" value="0">
                    </div>
                    <div class="slider-group">
                        <div class="slider-header">
                            <span>Thermodynamic Gravity Factor ($k_{TG}$)</span>
                            <span id="thermoGravityFactorVal">0.1</span>
                        </div>
                        <input type="range" id="thermoGravityFactor" min="0.0" max="1.0" step="0.01" value="0.1">
                    </div>
                    <div class="slider-group">
                        <div class="slider-header">
                            <span>Entropy Evolution Rate ($\nu_S$)</span>
                            <span id="entropyEvolutionRateVal">0.01</span>
                        </div>
                        <input type="range" id="entropyEvolutionRate" min="0.0" max="0.1" step="0.001" value="0.01">
                    </div>
                    <div class="slider-group">
                        <div class="slider-header">
                            <span>Decoherence Coupling Factor ($k_{Decoh}$)</span>
                            <span id="decoherenceCouplingFactorVal">1.0</span>
                        </div>
                        <input type="range" id="decoherenceCouplingFactor" min="0.0" max="10.0" step="0.1" value="1.0">
                    </div>
                </div>

                <div id="fossilControls" class="panel hidden">
                    <h2 style="font-size: 1.3rem; font-weight: bold; margin-bottom: 1rem; color: var(--highlight-color);">Cosmic Fossil Record Parameters</h2>
                    <p class="subtitle" style="font-size: 0.95rem; margin-bottom: 1rem;">
                        This module simulates the decay of usable cosmic energy and galactic cold gas mass.
                        It also provides a calculation for cosmic time based on redshift.
                    </p>
                    <div class="controls">
                        <button id="runFossilSimBtn">Run Energy/Gas Simulation</button>
                        <button id="resetFossilBtn">Reset</button>
                        <button id="exportFossilCSVBtn">Export Results (CSV)</button>
                    </div>
                    <div class="input-group">
                        <div class="input-header">
                            <span>Initial Time (t₀ Gyr)</span>
                            <span id="fossil_t0_val">13.8</span>
                        </div>
                        <input type="number" id="fossil_t0" value="13.8" min="0.1" step="0.1">
                        <span class="error-message" id="fossil_t0_error"></span>
                    </div>
                    <div class="input-group">
                        <div class="input-header">
                            <span>Max Time (t<sub>max</sub> Gyr)</span>
                            <span id="fossil_tmax_val">200</span>
                        </div>
                        <input type="number" id="fossil_tmax" value="200" min="50" step="10">
                        <span class="error-message" id="fossil_tmax_error"></span>
                    </div>
                    <div class="input-group">
                        <div class="input-header">
                            <span>Time Step (dt Gyr)</span>
                            <span id="fossil_dt_val">0.1</span>
                        </div>
                        <input type="number" id="fossil_dt" value="0.1" min="0.01" step="0.01">
                        <span class="error-message" id="fossil_dt_error"></span>
                    </div>
                    <div class="input-group">
                        <div class="input-header">
                            <span>Population Decay Rate ($\beta$)</span>
                            <span id="fossil_beta_val">0.03</span>
                        </div>
                        <input type="number" id="fossil_beta" value="0.03" min="0.01" max="0.1" step="0.005">
                        <span class="error-message" id="fossil_beta_error"></span>
                    </div>

                    <h3 style="font-size: 1.1rem; font-weight: bold; margin-top: 1.5rem; color: var(--highlight-color);">Cosmic Time at Redshift</h3>
                    <p class="subtitle" style="font-size: 0.95rem; margin-bottom: 1rem;">Calculates the estimated cosmic age at a given redshift (z).</p>
                    <div class="input-group">
                        <label for="z_fossil_new">Redshift z:</label>
                        <input id="z_fossil_new" type="number" value="5" step="0.5" min="0">
                        <span class="error-message" id="z_fossil_new_error"></span>
                    </div>
                    <button id="computeFossilTimeBtn" style="margin-bottom: 1rem;">Calculate Cosmic Time</button>
                    <pre id="fossilTimeOutput" style="min-height: 2rem;"></pre>
                    <canvas id="fossilTimeCanvas" width="400" height="200"></canvas>
                    <pre id="fossilTimePlotInfo" style="margin-top: 1rem;">Cosmic Time Plot: (x-axis: redshift, y-axis: cosmic time in Gyr)</pre>
                </div>
                <div id="galacticControls" class="panel hidden">
                    <h2 style="font-size: 1.3rem; font-weight: bold; margin-bottom: 1rem; color: var(--highlight-color);">Galactic Evolution Parameters</h2>
                    <div class="controls">
                        <button id="runGalacticSimBtn">Run Simulation</button>
                        <button id="resetGalacticBtn">Reset</button>
                        <button id="exportGalacticCSVBtn">Export Results (CSV)</button>
                    </div>
                    <div class="input-group">
                        <div class="input-header">
                            <span>Quenching Rate ($\alpha$ Gyr⁻¹)</span>
                            <span id="galactic_alpha_val">0.25</span>
                        </div>
                        <input type="number" id="galactic_alpha" value="0.25" min="0.01" max="1.0" step="0.01">
                        <span class="error-message" id="galactic_alpha_error"></span>
                    </div>
                    <div class="input-group">
                        <div class="input-header">
                            <span>Initial Active Galaxies (N₀)</span>
                            <span id="galactic_N0_val">2,000,000,000,000</span>
                        </div>
                        <input type="number" id="galactic_N0" value="2000000000000" min="1000000000" step="100000000">
                        <span class="error-message" id="galactic_N0_error"></span>
                    </div>
                    <div class="input-group">
                        <div class="input-header">
                            <span>New Galaxy Formation Rate (Ṅ<sub>f</sub> galaxies/Gyr)</span>
                            <span id="galactic_Nf_dot_val">5,000,000,000</span>
                        </div>
                        <input type="number" id="galactic_Nf_dot" value="5000000000" min="100000000" step="100000000">
                        <span class="error-message" id="galactic_Nf_dot_error"></span>
                    </div>
                    <div class="input-group">
                        <div class="input-header">
                            <span>Total Simulation Time (Gyr)</span>
                            <span id="galactic_total_time_val">120</span>
                        </div>
                        <input type="number" id="galactic_total_time" value="120" min="10" step="10">
                        <span class="error-message" id="galactic_total_time_error"></span>
                    </div>
                    <div class="input-group">
                        <div class="input-header">
                            <span>Time Step (dt Gyr)</span>
                            <span id="galactic_dt_val">1.0</span>
                        </div>
                        <input type="number" id="galactic_dt" value="1.0" min="0.1" step="0.1">
                        <span class="error-message" id="galactic_dt_error"></span>
                    </div>
                    <canvas id="galacticEvolutionCanvasOriginal" width="400" height="200"></canvas>
                    <pre id="galacticEvolutionPlotInfoOriginal" style="margin-top: 1rem;">Galaxy Population Plot: (x-axis: time in Gyr, y-axis: active galaxies)</pre>
                </div>

                <div id="retractionControls" class="panel hidden">
                    <h2 style="font-size: 1.3rem; font-weight: bold; margin-bottom: 1rem; color: var(--highlight-color);">Thermodynamic Retraction Parameters</h2>
                    <div class="controls">
                        <button id="runRetractionSimBtn">Run Simulation</button>
                        <button id="resetRetractionBtn">Reset</button>
                        <button id="exportRetractionCSVBtn">Export Results (CSV)</button>
                    </div>
                    <div class="input-group">
                        <div class="input-header">
                            <span>Max Time (t<sub>max</sub> Gyr)</span>
                            <span id="retraction_tmax_val">500</span>
                        </div>
                        <input type="number" id="retraction_tmax" value="500" min="100" step="50">
                        <span class="error-message" id="retraction_tmax_error"></span>
                    </div>
                    <div class="input-group">
                        <div class="input-header">
                            <span>Time Step (dt Gyr)</span>
                            <span id="retraction_dt_val">1.0</span>
                        </div>
                        <input type="number" id="retraction_dt" value="1.0" min="0.1" step="0.1">
                        <span class="error-message" id="retraction_dt_error"></span>
                    </div>
                    <div class="input-group">
                        <div class="input-header">
                            <span>Retraction Factor ($\beta_{retraction}$)</span>
                            <span id="retraction_beta_val">0.05</span>
                        </div>
                        <input type="number" id="retraction_beta" value="0.05" min="0.001" max="0.1" step="0.001">
                        <span class="error-message" id="retraction_beta_error"></span>
                    </div>
                    <canvas id="retractionCanvas" width="400" height="200"></canvas>
                    <pre id="retractionPlotInfo" style="margin-top: 1rem;">Observable Volume Plot: (x-axis: time in Gyr, y-axis: normalized volume)</pre>
                </div>


                <div id="commonInfoBox" class="info-box active">
                    <h3 style="font-weight: bold; color: var(--highlight-color); margin-bottom: 0.75rem;">Physical Model for Gravitational Potential</h3>
                    <p style="margin-bottom: 0.5rem;">The gravitational potential within the core is described by the equation:</p>
                    <p class="equation">V(r,t) = V₀·e<sup>-α·r</sup> · cos(ω·r + $\phi_0$(t)) + β·(1 - e<sup>-r</sup>)·r<sup>-1</sup></p>
                    <p style="font-size: 0.85rem; color: var(--text-color-secondary);">
                        Where: $V_0$ = oscillation amplitude, $\alpha$ = exponential decay rate, $\omega$ = angular frequency, $\phi_0$(t) = animation phase (time-dependent), $\beta$ = central potential coefficient (singularity-free), r = normalized radial distance.
                        This model inherently avoids singularities at the origin.
                    </p>
                    <h3 style="font-weight: bold; color: var(--highlight-color); margin-top: 1.5rem; margin-bottom: 0.75rem;">Dynamic Entropic Gradient and Information Gravity</h3>
                    <p style="margin-bottom: 0.5rem;">The entropic gradient ∇S(r,t) is conceptually derived from the potential and local density:</p>
                    <p class="equation">∇S(r,t) ≈ - (dV/dr) · $\rho$(r,t)</p>
                    <p style="font-size: 0.85rem; color: var(--text-color-secondary);">
                        Where: dV/dr is the derivative of the gravitational potential, and $\rho$(r,t) is the local density, assumed to decay exponentially with radial distance and time for illustrative purposes.
                        A "causal boundary" is shown where $\rho$(r) becomes negligible. **Thermodynamic information gravity** is modeled by coupling the entropy gradient with metric deformations: $\delta G_{\mu\nu} \sim \nabla_\mu S \nabla_\nu S$.
                    </p>
                    <h3 style="font-weight: bold; color: var(--highlight-color); margin-top: 1.5rem; margin-bottom: 0.75rem;">Quantum Metric Regularization & Theory of Everything (TOE) Precursor</h3>
                    <p style="font-size: 0.85rem; color: var(--text-color-secondary);">
                        This simulator conceptually integrates components for the dynamic metric tensor ($g_{\mu\nu}(r,t)$), including quantum vacuum pressure and entropic stratification, towards a unified stress-energy tensor.
                        This aims to explore scenarios where singularities are avoided through thermodynamically consistent formulations. The conceptual Einstein Field Equation is:<br>
                    <p class="equation">G<sub>μν</sub> + Λg<sub>μν</sub> = 8πG (T<sub>μν</sub><sup>matter</sup> + T<sub>μν</sub><sup>vacuum</sup> + T<sub>μν</sub><sup>entropy</sup>)</p>
                    A conceptual **quantum decoherence rate** is also calculated, simulating the loss of quantum coherence near the core due to gravitational interactions and thermal dissipation.
                    The **total DUT Hamiltonian** is conceptually represented by the sum of energies associated with gravity, quantum fields, and entropy: $H_{total} = H_{GR} + H_{QG} + H_{entropy}$.
                    </p>
                    <h3 style="font-weight: bold; color: var(--highlight-color); margin-top: 1.5rem; margin-bottom: 0.75rem;">Note on Advanced Simulations</h3>
                    <p style="font-size: 0.85rem; color: var(--text-color-secondary);">
                        For full resolution of dynamic tensor equations and 3D/4D rendering with spatial voxelization at high fidelity, migration to cloud supercomputing platforms using technologies such as WebAssembly (WASM), CUDA, JAX, or PyTorch would be necessary.
                        The current implementation focuses on conceptual models and enhanced 1D visualizations in a browser environment.
                    </p>
                </div>
            </div>

            <div>
                <canvas id="mainCanvas"></canvas>
                <div id="potentialResultsBox" class="results-box active">
                    <h2>Predicted Thermodynamic and Cosmological Parameters:</h2>
                    <div id="results" class="results-content">
                        T<sub>core</sub> &asymp; -- K<br>
                        M<sub>core</sub> &asymp; -- solar masses<br>
                        &Omega;<sub>k</sub> &asymp; --<br>
                        g<sub>tt</sub> (at R<sub>core</sub>, t) &asymp; -- <br>
                        g<sub>rr</sub> (at R<sub>core</sub>, t) &asymp; -- <br>
                        Proper Time Dilation Factor (at R<sub>core</sub>, t) &asymp; -- <br>
                        Conceptual Quantum Decoherence Rate (at R<sub>core</sub>, t) &asymp; -- Hz<br>
                        Total Stress-Energy Density (at R<sub>core</sub>, t) &asymp; -- kg/m³
                    </div>
                </div>
                <div id="fossilResultsBox" class="results-box hidden">
                    <h2>Cosmic Fossil Record Simulation Results:</h2>
                    <div id="fossil_results" class="results-content">
                        Estimated Cosmic Energy Extinction Time: -- Gyr<br>
                        Final Usable Energy: -- (Normalized Units)<br>
                        Final Cold Gas Mass: -- (Normalized Units)<br><br>
                        Calculated Cosmic Time at Redshift:<br>
                        Estimated cosmic time at z=5: ≈ -- Gyr
                    </div>
                </div>
                <div id="galacticResultsBox" class="results-box hidden">
                    <h2>Galactic Evolution Simulation Results:</h2>
                    <div id="galactic_results" class="results-content">
                        Initial Active Galaxies: -- <br>
                        Final Active Galaxies: --
                    </div>
                </div>
                <div id="retractionResultsBox" class="results-box hidden">
                    <h2>Thermodynamic Retraction Simulation Results:</h2>
                    <div id="retraction_results" class="results-content">
                        Total Simulated Time: -- Gyr<br>
                        Final Observable Volume: -- (Normalized)
                    </div>
                </div>

                <div id="observationalDataPanel" class="panel">
                    <h2 style="font-size: 1.3rem; font-weight: bold; margin-bottom: 1rem; color: var(--highlight-color);">Observational Data (Simulated & Imported)</h2>
                    <p class="subtitle" style="font-size: 0.95rem; margin-bottom: 1rem; color: var(--warning-color);">
                        **Important Note:** Direct connections to real scientific database APIs are restricted.
                        You can use **simulated data** provided below, or **import your own data file** (CSV/JSON)
                        which you can manually download from agency portals (e.g., NASA, ESA, JAXA, Roscosmos).
                    </p>
                    <div class="controls">
                        <button id="loadJWSTDataBtn">Load Simulated JWST Data</button>
                        <button id="loadNASAEarthDataBtn">Load Simulated NASA Earth Data</button>
                        <input type="file" id="localFileInput" accept=".csv,.json" style="display: none;">
                        <button id="loadLocalFileBtn">Import Data File</button>
                    </div>
                    <pre id="observationalDataDisplay">No observational data loaded yet. Try loading simulated data or importing a file.</pre>
                </div>
            </div>
        </div>
        <div id="localLedgerSection" class="panel">
            <h2 style="font-size: 1.3rem; font-weight: bold; margin-bottom: 1rem; color: var(--highlight-color);">Local Scientific Ledger (Proof of Concept)</h2>
            <p class="subtitle" style="font-size: 0.95rem; margin-bottom: 1rem;">
                This section demonstrates a conceptual, blockchain-like, local ledger. It uses your browser's local storage to save hashed records of your simulation data.
                This ledger is **only local to your browser** and does not interact with external networks.
                It serves to illustrate the principle of immutability and data chaining for your personal records.
            </p>
            <div id="privacySelector">
                <label for="recordPrivacy">Record Privacy:</label>
                <select id="recordPrivacy">
                    <option value="private">Private (Local Only)</option>
                    <option value="public">Public (Intention to Share)</option>
                </select>
            </div>
            <div id="localLedgerControls">
                <button id="recordDataBtn">Record Current Data to Local Ledger</button>
                <button id="viewLedgerBtn">View Local Ledger History</button>
                <button id="exportLedgerCSVBtn">Export Full Local Ledger (CSV)</button>
                <button id="clearLedgerBtn">Clear Local Ledger</button>
            </div>
            <pre id="localLedgerStatus">Ledger Status: No records yet.</pre>
            <div id="localLedgerHistory" class="hidden">
                <h3 style="font-size: 1.1rem; font-weight: bold; margin-top: 1.5rem; color: var(--highlight-color);">Ledger History:</h3>
                <pre id="ledgerHistoryContent" style="background: var(--input-bg); border: 1px solid var(--input-border); padding: 1rem; border-radius: 8px; max-height: 400px; overflow-y: auto;"></pre>
            </div>
            <h3 style="font-size: 1.1rem; font-weight: bold; margin-top: 1.5rem; color: var(--highlight-color);">Manual SHA-256 Hashing</h3>
            <p class="subtitle" style="font-size: 0.95rem; margin-bottom: 1rem;">Paste any data into the text area below to generate its SHA-256 hash.
                Useful for verifying data integrity or creating custom ledger entries.</p>
            <div class="input-group">
                <textarea id="simDataManual" placeholder="Paste any data here to generate its SHA-256 hash..." rows="4"></textarea>
                <span class="error-message" id="simDataManual_error"></span>
            </div>
            <button id="generateManualHashBtn">Generate SHA-256 Hash</button>
            <pre id="hashOutput" style="min-height: 2rem;"></pre>
        </div>

        <div id="aiAssistantPanel" class="panel">
            <h2 style="font-size: 1.3rem; font-weight: bold; margin-bottom: 1rem; color: var(--highlight-color);">DUT Consistency Assistant</h2>
            <p class="subtitle" style="font-size: 0.95rem; margin-bottom: 1rem;">
                This simple rule-based assistant checks simulation parameters and results for conceptual inconsistencies and offers suggestions.
            </p>
            <div id="aiAssistantControls">
                <button id="runAIAssistantCheckBtn">Run AI Check</button>
            </div>
            <pre id="aiAssistantOutput">The assistant is ready to analyze your parameters.</pre>
        </div>

        <div id="consistencyCheckSection" class="panel">
            <h2 style="font-size: 1.3rem; font-weight: bold; margin-top: 2rem; margin-bottom: 1rem; color: var(--highlight-color);">Internal Scientific Consistency Check</h2>
            <p class="subtitle" style="font-size: 0.95rem; margin-bottom: 1rem;">
                Performs a meta-consistency check between different simulation modules to ensure logical coherence within the DUT model.
            </p>
            <div id="consistencyCheckControls">
                <button id="runConsistencyCheckBtn">Run Overall Consistency Check</button>
            </div>
            <h3 style="font-size: 1.1rem; font-weight: bold; margin-top: 1.5rem; color: var(--highlight-color);">DUT Regime Validity Score</h3>
            <p class="subtitle" style="font-size: 0.95rem; margin-bottom: 1rem;">
                Evaluates the theoretical validity of the DUT model in specific cosmic regimes based on maximum redshift and minimum observed mass.
            </p>
            <div class="input-group">
                <label for="z_consist_new">Maximum Redshift (z<sub>max</sub>):</label>
                <input id="z_consist_new" type="number" value="20" min="0">
                <span class="error-message" id="z_consist_new_error"></span>
            </div>
            <div class="input-group">
                <label for="m_consist_new">Minimum Observed Mass (M☉):</label>
                <input id="m_consist_new" type="number" value="1e8" min="0">
                <span class="error-message" id="m_consist_new_error"></span>
            </div>
            <button id="checkConsistencyBtn" style="margin-bottom: 1rem;">Evaluate Regime Validity</button>
            <pre id="consistencyOutput" style="min-height: 2rem;"></pre>
        </div>

        <div class="panel" style="margin-top: 2rem;">
            <h2 style="color: var(--highlight-color);">DUT Self-Refutation & Robustness Panel</h2>
            <p class="subtitle" style="font-size: 0.95rem; margin-bottom: 1rem;">Evaluate theoretical robustness based on predictions, confirmations, and falsifications.
                This serves as a conceptual tool for epistemic meta-analysis within the DUT framework.</p>
            <div class="controls">
                <div class="input-group">
                    <div class="input-header">
                        <span>Predicted Events</span>
                    </div>
                    <input type="number" id="predictedEvents" placeholder="e.g., 5" min="0" value="0">
                    <span class="error-message" id="predictedEvents_error"></span>
                </div>
                <div class="input-group">
                    <div class="input-header">
                        <span>Confirmed Events</span>
                    </div>
                    <input type="number" id="confirmedEvents" placeholder="e.g., 3" min="0" value="0">
                    <span class="error-message" id="confirmedEvents_error"></span>
                </div>
                <div class="input-group">
                    <div class="input-header">
                        <span>Falsified Events</span>
                    </div>
                    <input type="number" id="falsifiedEvents" placeholder="e.g., 1" min="0" value="0">
                    <span class="error-message" id="falsifiedEvents_error"></span>
                </div>
                <button id="runRefutationBtn">Calculate Score</button>
                <button id="exportRefutationJSONBtn">Export .JSON</button>
                <button id="exportRefutationTXTBtn">Export .TXT</button>
            </div>
            <div id="refutationResult" style="color: var(--results-text-color); font-weight: bold; margin-top: 0.5rem; font-size: 1rem;"></div>
            <div id="refutationHash" style="font-size: 0.8rem; margin-top: 0.5rem; color: var(--text-color-secondary);"></div>
        </div>
        <div id="interactiveConsolePanel" class="panel">
            <h2 style="font-size: 1.3rem; font-weight: bold; margin-bottom: 1rem; color: var(--highlight-color);">DUT Interactive Console</h2>
            <p class="subtitle" style="font-size: 0.95rem; margin-bottom: 1rem;">
                Interact with the simulator using natural language commands. Try "help", "show constants", "simulate fossil with tmax 300", "load JWST data", or "explain potential equation".
            </p>
            <pre id="consoleOutput">Welcome to the DUT Interactive Console. Type 'help' for commands.</pre>
            <div style="display: flex; gap: 0.5rem;">
                <input type="text" id="consoleInput" placeholder="Type your command...">
                <button id="consoleInputBtn">Send</button>
            </div>
        </div>
        <div id="srdModulePanel" class="advanced-module-panel">
            <h2>SRD Abundance at z ≈ 20</h2>
            <p class="subtitle" style="font-size: 0.95rem; margin-bottom: 1rem;">Simulates the conceptual abundance of Spontaneously Recombining Dark (SRD) particles at high redshift, reflecting a theoretical early universe phase.</p>
            <div class="controls" style="justify-content: flex-start;">
                <div class="input-group" style="width: auto;">
                    <label for="betaSRD">Beta ($\beta$):</label>
                    <input id="betaSRD" type="number" value="2.5" step="0.1" min="0.1">
                    <span class="error-message" id="betaSRD_error"></span>
                </div>
                <div class="input-group" style="width: auto;">
                    <label for="gammaSRD">Gamma ($\gamma$):</label>
                    <input id="gammaSRD" type="number" value="0.5" step="0.1" min="0.1">
                    <span class="error-message" id="gammaSRD_error"></span>
                </div>
                <button id="plotSRDBtn">Simulate SRDs</button>
            </div>
            <canvas id="srdCanvas" width="400" height="200"></canvas>
            <pre id="srdOutput" style="margin-top: 1rem;">SRD Abundance Plot: (x-axis: redshift, y-axis: relative abundance)</pre>
        </div>

        <div id="galaxyBirthDeathDatingModulePanel" class="advanced-module-panel">
            <h2>Galaxy Birth–Death Dating Model</h2>
            <p class="subtitle" style="font-size: 0.95rem; margin-bottom: 1rem;">Models the evolution of active galaxy populations over cosmic time, considering initial formation and a decay process, for conceptual cosmic dating.</p>
            <div class="controls" style="justify-content: flex-start;">
                <div class="input-group" style="width: auto;">
                    <label for="N0_galaxy_dating">Initial Formation Rate (N₀):</label>
                    <input id="N0_galaxy_dating" type="number" value="1000" step="10" min="0">
                    <span class="error-message" id="N0_galaxy_dating_error"></span>
                </div>
                <div class="input-group" style="width: auto;">
                    <label for="beta_galaxy_dating">Decay Constant ($\beta$ Gyr⁻¹):</label>
                    <input id="beta_galaxy_dating" type="number" value="0.01" step="0.001" min="0.001">
                    <span class="error-message" id="beta_galaxy_dating_error"></span>
                </div>
                <div class="input-group" style="width: auto;">
                    <label for="duration_galaxy_dating">Simulation Duration (Gyr):</label>
                    <input id="duration_galaxy_dating" type="number" value="200" step="10" min="0">
                    <span class="error-message" id="duration_galaxy_dating_error"></span>
                </div>
                <label>Include Rejuvenation Peak at z ≈ 6 <input id="rejuvenate_galaxy_dating" type="checkbox" checked></label>
                <button id="simulateGalaxyBirthDeathBtn_dating">Simulate Galaxy Population</button>
            </div>
            <canvas id="galaxyBirthDeathCanvas" width="600" height="300"></canvas>
            <pre id="galaxyBirthDeathLog"></pre>
        </div>

        <div id="cosmicFossilRecordSimulatorAdvancedPanel" class="advanced-module-panel">
            <h2>Cosmic Fossil Record Simulator (Advanced)</h2>
            <p class="subtitle" style="font-size: 0.95rem; margin-bottom: 1rem;">Simulates "fossil density" based on redshift, galaxy mass, and type, with an option to include JWST model data.</p>
            <div class="controls" style="justify-content: flex-start;">
                <div class="input-group" style="width: auto;">
                    <label for="mass_fossil_adv">Galaxy Mass (10^10 M☉):</label>
                    <input type="number" id="mass_fossil_adv" value="1.0" step="0.1" min="0">
                    <span class="error-message" id="mass_fossil_adv_error"></span>
                </div>
                <div class="input-group" style="width: auto;">
                    <label for="type_fossil_adv">Galaxy Type:</label>
                    <select id="type_fossil_adv">
                        <option value="elliptical">Elliptical</option>
                        <option value="lenticular">Lenticular</option>
                        <option value="spiral">Spiral</option>
                    </select>
                </div>
                <label>Include JWST Model Data: <input type="checkbox" id="includeData_fossil_adv" checked></label>
                <button id="simulateFossilsAdvancedBtn">Simulate Fossil Record</button>
                <button id="exportFossilDataAdvancedBtn">Export to CSV</button>
            </div>
            <canvas id="fossilCanvasAdvanced" width="600" height="300"></canvas>
        </div>


        <div id="hawkingRadiationModulePanel" class="advanced-module-panel">
            <h2>Hawking Radiation Evaporation Time</h2>
            <p class="subtitle" style="font-size: 0.95rem; margin-bottom: 1rem;">Calculates the theoretical evaporation time of black holes due to Hawking radiation, a quantum gravitational effect.</p>
            <div class="controls" style="justify-content: flex-start;">
                <div class="input-group" style="width: auto;">
                    <label for="bhMass">Select BH Mass (M☉):</label>
                    <select id="bhMass">
                        <option value="1e5">10^5 Solar Masses</option>
                        <option value="1e8">10^8 Solar Masses</option>
                        <option value="1e9">10^9 Solar Masses</option>
                        <option value="1e10">10^10 Solar Masses</option>
                        <option value="1e11">10^11 Solar Masses</option>
                        <option value="1e12">10^12 Solar Masses</option>
                    </select>
                </div>
                <button id="calcEvaporationBtn">Calculate Evaporation</button>
            </div>
            <pre id="hawkingOutput"></pre>
        </div>

        <div id="curvatureModulePanel" class="advanced-module-panel">
            <h2>Spacetime Curvature Model</h2>
            <p class="subtitle" style="font-size: 0.95rem; margin-bottom: 1rem;">Conceptual model illustrating different global spacetime curvatures within the DUT framework.</p>
            <div class="controls" style="justify-content: flex-start;">
                <label style="margin-right: 1rem;"><input type="radio" name="curv" value="1" checked> Positive (Closed)</label>
                <label style="margin-right: 1rem;"><input type="radio" name="curv" value="-1"> Negative (Open)</label>
                <label><input type="radio" name="curv" value="0"> Asymmetric (Flat-like with Perturbation)</label>
                <button id="displayCurvatureBtn">Simulate Curvature</button>
            </div>
            <pre id="curvatureOutput"></pre>
        </div>

        <div id="darkBiologyModulePanel" class="advanced-module-panel">
            <h2>Dark Biology Simulation</h2>
            <p class="subtitle" style="font-size: 0.95rem; margin-bottom: 1rem;">Explores the conceptual "bio-potential" in extreme cosmic environments based on entropy gradients, a speculative aspect of DUT.</p>
            <div class="controls" style="justify-content: flex-start;">
                <div class="input-group" style="width: auto;">
                    <label for="entropyGrad">Entropy Gradient ($\nabla S$):</label>
                    <input id="entropyGrad" type="number" value="-0.005" step="0.001">
                    <span class="error-message" id="entropyGrad_error"></span>
                </div>
                <div class="input-group" style="width: auto;">
                    <label for="lambdaBio">Lambda (Suppression Factor):</label>
                    <input id="lambdaBio" type="number" value="10" step="1" min="0">
                    <span class="error-message" id="lambdaBio_error"></span>
                </div>
                <button id="simulateBiologyBtn">Check Bio-Potential</button>
            </div>
            <pre id="bioOutput"></pre>
        </div>

        <div id="mirrorModulePanel" class="advanced-module-panel">
            <h2>DUT Quantum Mirror Experiment: Gravitational Reflection Delay</h2>
            <p class="subtitle" style="font-size: 0.95rem; margin-bottom: 1rem;">
                Simulates the theoretical delay in light reflection from a distant quantum mirror, incorporating classical travel time, entropy-induced deformation, and local gravitational perturbations. This module is a core component for exploring quantum gravity effects within the DUT.
            </p>
            <div class="controls" style="justify-content: flex-start; flex-direction: column; align-items: flex-start;">
                <div class="input-group" style="width: 100%;">
                    <label for="D_mirror">Distance D (light-years):</label>
                    <input id="D_mirror" type="number" value="1" step="0.1" min="0.1">
                    <span class="error-message" id="D_mirror_error"></span>
                </div>
                <div class="input-group" style="width: 100%;">
                    <label for="gradS_mirror">Entropy Gradient ∇S (conceptual units, e.g., kB):</label>
                    <input id="gradS_mirror" type="number" value="-0.01" step="0.001">
                    <span class="error-message" id="gradS_mirror_error"></span>
                </div>
                <div class="input-group" style="width: 100%;">
                    <label for="deltaG_mirror">Local Gravity Perturbation δg (conceptual):</label>
                    <input id="deltaG_mirror" type="number" value="0.001" step="0.0001" min="0">
                    <span class="error-message" id="deltaG_mirror_error"></span>
                </div>
                <div class="input-group" style="width: 100%;">
                    <label for="eta_mirror">Reality Deformation Factor η (0–1):</label>
                    <input id="eta_mirror" type="number" value="0.1" step="0.01" min="0" max="1">
                    <span class="error-message" id="eta_mirror_error"></span>
                </div>
                <button id="simulateMirrorBtn">Run Simulation</button>
            </div>
            <pre id="mirrorOutput"></pre>
        </div>
        <div id="messageBox" class="message-box"></div>
    </div>
    <script>
        // ==========================================
        // Module: Global Configuration and UI Elements
        // ==========================================
        // Main canvas for 1D potential visualization
        const mainCanvas = document.getElementById('mainCanvas');
        const ctx = mainCanvas.getContext('2d');
        // UI elements for Gravitational Potential
        const amplitudeSlider = document.getElementById('amplitude');
        const frequencySlider = document.getElementById('frequency');
        const decaySlider = document.getElementById('decay');
        const centralSlider = document.getElementById('central');
        const radiusSlider = document.getElementById('radius');
        const densitySlider = document.getElementById('density');
        const simTimeSlider = document.getElementById('simTime');
        const thermoGravityFactorSlider = document.getElementById('thermoGravityFactor');
        const entropyEvolutionRateSlider = document.getElementById('entropyEvolutionRate');
        const decoherenceCouplingFactorSlider = document.getElementById('decoherenceCouplingFactor');
        const amplitudeValueSpan = document.getElementById('amplitudeValue');
        const frequencyValueSpan = document.getElementById('frequencyValue');
        const decayValueSpan = document.getElementById('decayValue');
        const centralValueSpan = document.getElementById('centralValue');
        const radiusValueSpan = document.getElementById('radiusVal');
        const densityValueSpan = document.getElementById('densityVal');
        const simTimeValSpan = document.getElementById('simTimeVal');
        const thermoGravityFactorValSpan = document.getElementById('thermoGravityFactorVal');
        const entropyEvolutionRateValSpan = document.getElementById('entropyEvolutionRateVal');
        const decoherenceCouplingFactorValSpan = document.getElementById('decoherenceCouplingFactorVal');
        const mode1DButton = document.getElementById('mode1D');
        const animateButton = document.getElementById('animateBtn');
        const resetButton = document.getElementById('resetBtn');
        const exportPotentialCSVBtn = document.getElementById('exportPotentialCSVBtn');
        const potentialResultsDiv = document.getElementById('results');
        const potentialControlsDiv = document.getElementById('potentialControls');
        const potentialResultsBox = document.getElementById('potentialResultsBox');
        // UI elements for Cosmic Fossil Record
        const fossilControlsDiv = document.getElementById('fossilControls');
        const runFossilSimBtn = document.getElementById('runFossilSimBtn');
        const resetFossilBtn = document.getElementById('resetFossilBtn');
        const exportFossilCSVBtn = document.getElementById('exportFossilCSVBtn');
        const fossilResultsBox = document.getElementById('fossilResultsBox');
        const fossilResultsDiv = document.getElementById('fossil_results');
        const fossil_t0_input = document.getElementById('fossil_t0');
        const fossil_tmax_input = document.getElementById('fossil_tmax');
        const fossil_dt_input = document.getElementById('fossil_dt');
        const fossil_beta_input = document.getElementById('fossil_beta');
        const fossil_t0_val_span = document.getElementById('fossil_t0_val');
        const fossil_tmax_val_span = document.getElementById('fossil_tmax_val');
        const fossil_dt_val_span = document.getElementById('fossil_dt_val');
        const fossil_beta_val_span = document.getElementById('fossil_beta_val');
        const fossil_t0_error_span = document.getElementById('fossil_t0_error');
        const fossil_tmax_error_span = document.getElementById('fossil_tmax_error');
        const fossil_dt_error_span = document.getElementById('fossil_dt_error');
        const fossil_beta_error_span = document.getElementById('fossil_beta_error');
        // UI elements for Galactic Evolution
        const galacticControlsDiv = document.getElementById('galacticControls');
        const runGalacticSimBtn = document.getElementById('runGalacticSimBtn');
        const resetGalacticBtn = document.getElementById('resetGalacticBtn');
        const exportGalacticCSVBtn = document.getElementById('exportGalacticCSVBtn');
        const galacticResultsBox = document.getElementById('galacticResultsBox');
        const galacticResultsDiv = document.getElementById('galactic_results');
        const galactic_alpha_input = document.getElementById('galactic_alpha');
        const galactic_N0_input = document.getElementById('galactic_N0');
        const galactic_Nf_dot_input = document.getElementById('galactic_Nf_dot');
        const galactic_total_time_input = document.getElementById('galactic_total_time');
        const galactic_dt_input = document.getElementById('galactic_dt');
        const galactic_alpha_val_span = document.getElementById('galactic_alpha_val');
        const galactic_N0_val_span = document.getElementById('galactic_N0_val');
        const galactic_Nf_dot_val_span = document.getElementById('galactic_Nf_dot_val');
        const galactic_total_time_val_span = document.getElementById('galactic_total_time_val');
        const galactic_dt_val_span = document.getElementById('galactic_dt_val');
        const galactic_alpha_error_span = document.getElementById('galactic_alpha_error');
        const galactic_N0_error_span = document.getElementById('galactic_N0_error');
        const galactic_Nf_dot_error_span = document.getElementById('galactic_Nf_dot_error');
        const galactic_total_time_error_span = document.getElementById('galactic_total_time_error');
        const galactic_dt_error_span = document.getElementById('galactic_dt_error');
        const galacticEvolutionCanvasOriginal = document.getElementById('galacticEvolutionCanvasOriginal'); // Renamed from galacticEvolutionCanvas
        const galacticEvolutionCtxOriginal = galacticEvolutionCanvasOriginal.getContext('2d'); // Context for original galactic evolution
        const galacticEvolutionPlotInfoOriginal = document.getElementById('galacticEvolutionPlotInfoOriginal'); // Renamed from galacticEvolutionPlotInfo

        // UI elements for Thermodynamic Retraction (NEW)
        const modeRetractionBtn = document.getElementById('modeRetractionBtn');
        const retractionControlsDiv = document.getElementById('retractionControls');
        const runRetractionSimBtn = document.getElementById('runRetractionSimBtn');
        const resetRetractionBtn = document.getElementById('resetRetractionBtn');
        const exportRetractionCSVBtn = document.getElementById('exportRetractionCSVBtn');
        const retractionResultsBox = document.getElementById('retractionResultsBox');
        const retractionResultsDiv = document.getElementById('retraction_results');
        const retraction_tmax_input = document.getElementById('retraction_tmax');
        const retraction_dt_input = document.getElementById('retraction_dt');
        const retraction_beta_input = document.getElementById('retraction_beta');
        const retraction_tmax_val_span = document.getElementById('retraction_tmax_val');
        const retraction_dt_val_span = document.getElementById('retraction_dt_val');
        const retraction_beta_val_span = document.getElementById('retraction_beta_val');
        const retraction_tmax_error_span = document.getElementById('retraction_tmax_error');
        const retraction_dt_error_span = document.getElementById('retraction_dt_error');
        const retraction_beta_error_span = document.getElementById('retraction_beta_error');
        const retractionCanvas = document.getElementById('retractionCanvas');
        const retractionCtx = retractionCanvas.getContext('2d');

        // Main mode selection buttons
        const allModeButtons = [modePotentialBtn, modeFossilBtn, modeGalacticBtn, modeRetractionBtn];
        const allControlPanels = [potentialControlsDiv, fossilControlsDiv, galacticControlsDiv, retractionControlsDiv];
        const allResultsBoxes = [potentialResultsBox, fossilResultsBox, galacticResultsBox, retractionResultsBox];

        const commonInfoBox = document.getElementById('commonInfoBox');
        const messageBox = document.getElementById('messageBox');
        // Local Ledger UI elements
        const recordDataBtn = document.getElementById('recordDataBtn');
        const viewLedgerBtn = document.getElementById('viewLedgerBtn');
        const exportLedgerCSVBtn = document.getElementById('exportLedgerCSVBtn');
        const clearLedgerBtn = document.getElementById('clearLedgerBtn');
        const localLedgerStatus = document.getElementById('localLedgerStatus');
        const localLedgerHistory = document.getElementById('localLedgerHistory');
        const ledgerHistoryContent = document.getElementById('ledgerHistoryContent');
        const recordPrivacySelect = document.getElementById('recordPrivacy');
        // NEW Patch: Manual Hashing Elements
        const simDataManualInput = document.getElementById('simDataManual');
        const simDataManual_error_span = document.getElementById('simDataManual_error');
        const generateManualHashBtn = document.getElementById('generateManualHashBtn');
        const hashOutput = document.getElementById('hashOutput');
        // Observational Data UI elements
        const loadJWSTDataBtn = document.getElementById('loadJWSTDataBtn');
        const loadNASAEarthDataBtn = document.getElementById('loadNASAEarthDataBtn');
        const observationalDataDisplay = document.getElementById('observationalDataDisplay');
        const localFileInput = document.getElementById('localFileInput');
        const loadLocalFileBtn = document.getElementById('loadLocalFileBtn');
        // Consistency Check UI elements (NEW)
        const runConsistencyCheckBtn = document.getElementById('runConsistencyCheckBtn');
        // NEW Patch: DUT Regime Validity Score elements
        const z_consist_newInput = document.getElementById('z_consist_new');
        const m_consist_newInput = document.getElementById('m_consist_new');
        const z_consist_new_error_span = document.getElementById('z_consist_new_error');
        const m_consist_new_error_span = document.getElementById('m_consist_new_error');
        const checkConsistencyBtn = document.getElementById('checkConsistencyBtn');
        const consistencyOutput = document.getElementById('consistencyOutput');
        // AI Assistant UI elements (NEW)
        const aiAssistantPanel = document.getElementById('aiAssistantPanel');
        const runAIAssistantCheckBtn = document.getElementById('runAIAssistantCheckBtn');
        const aiAssistantOutput = document.getElementById('aiAssistantOutput');
        // Auto-Refutation UI elements (NEW)
        const predictedEventsInput = document.getElementById('predictedEvents');
        const confirmedEventsInput = document.getElementById('confirmedEvents');
        const falsifiedEventsInput = document.getElementById('falsifiedEvents');
        const predictedEventsErrorSpan = document.getElementById('predictedEvents_error');
        const confirmedEventsErrorSpan = document.getElementById('confirmedEvents_error');
        const falsifiedEventsErrorSpan = document.getElementById('falsifiedEvents_error');
        const runRefutationBtn = document.getElementById('runRefutationBtn');
        const exportRefutationJSONBtn = document.getElementById('exportRefutationJSONBtn');
        const exportRefutationTXTBtn = document.getElementById('exportRefutationTXTBtn');
        const refutationResultDiv = document.getElementById('refutationResult');
        const refutationHashDiv = document.getElementById('refutationHash');
        // Interactive Console UI elements (NEW)
        const consoleOutput = document.getElementById('consoleOutput');
        const consoleInput = document.getElementById('consoleInput');
        const consoleInputBtn = document.getElementById('consoleInputBtn');

        // NEW Advanced Modules UI Elements (from previous integration)
        const betaSRDInput = document.getElementById('betaSRD');
        const gammaSRDInput = document.getElementById('gammaSRD');
        const betaSRD_error_span = document.getElementById('betaSRD_error');
        const gammaSRD_error_span = document.getElementById('gammaSRD_error');
        const srdCanvas = document.getElementById('srdCanvas');
        const srdCtx = srdCanvas.getContext('2d');
        const plotSRDBtn = document.getElementById('plotSRDBtn');
        const srdOutput = document.getElementById('srdOutput');

        // Renamed elements for the new Galaxy Birth-Death Dating Model (from user's snippet)
        const N0_galaxy_dating_input = document.getElementById('N0_galaxy_dating');
        const beta_galaxy_dating_input = document.getElementById('beta_galaxy_dating');
        const duration_galaxy_dating_input = document.getElementById('duration_galaxy_dating');
        const rejuvenate_galaxy_dating_checkbox = document.getElementById('rejuvenate_galaxy_dating'); // New checkbox
        const N0_galaxy_dating_error_span = document.getElementById('N0_galaxy_dating_error');
        const beta_galaxy_dating_error_span = document.getElementById('beta_galaxy_dating_error');
        const duration_galaxy_dating_error_span = document.getElementById('duration_galaxy_dating_error');
        const simulateGalaxyBirthDeathBtn_dating = document.getElementById('simulateGalaxyBirthDeathBtn_dating');
        const galaxyBirthDeathCanvas = document.getElementById('galaxyBirthDeathCanvas'); // Renamed from galaxyCanvas
        const galaxyBirthDeathCtx = galaxyBirthDeathCanvas.getContext('2d'); // Context for renamed canvas
        const galaxyBirthDeathLog = document.getElementById('galaxyBirthDeathLog'); // Renamed from galaxyLog

        const bhMassSelect = document.getElementById('bhMass');
        const calcEvaporationBtn = document.getElementById('calcEvaporationBtn');
        const hawkingOutput = document.getElementById('hawkingOutput');

        const curvRadio1 = document.querySelector('input[name="curv"][value="1"]');
        const curvRadio2 = document.querySelector('input[name="curv"][value="-1"]');
        const curvRadio3 = document.querySelector('input[name="curv"][value="0"]');
        const displayCurvatureBtn = document.getElementById('displayCurvatureBtn');
        const curvatureOutput = document.getElementById('curvatureOutput');

        const entropyGradInput = document.getElementById('entropyGrad');
        const lambdaBioInput = document.getElementById('lambdaBio');
        const entropyGrad_error_span = document.getElementById('entropyGrad_error');
        const lambdaBio_error_span = document.getElementById('lambdaBio_error');
        const simulateBiologyBtn = document.getElementById('simulateBiologyBtn');
        const bioOutput = document.getElementById('bioOutput');

        // NEW Quantum Mirror Module UI Elements
        const D_mirrorInput = document.getElementById('D_mirror');
        const gradS_mirrorInput = document.getElementById('gradS_mirror');
        const deltaG_mirrorInput = document.getElementById('deltaG_mirror');
        const eta_mirrorInput = document.getElementById('eta_mirror');
        const D_mirror_error_span = document.getElementById('D_mirror_error');
        const gradS_mirror_error_span = document.getElementById('gradS_mirror_error');
        const deltaG_mirror_error_span = document.getElementById('deltaG_mirror_error');
        const eta_mirror_error_span = document.getElementById('eta_mirror_error');
        const simulateMirrorBtn = document.getElementById('simulateMirrorBtn');
        const mirrorOutput = document.getElementById('mirrorOutput');

        // NEW Patch: Cosmic Time by Redshift elements (Integrated into Fossil Record module HTML)
        const z_fossil_newInput = document.getElementById('z_fossil_new');
        const z_fossil_new_error_span = document.getElementById('z_fossil_new_error');
        const computeFossilTimeBtn = document.getElementById('computeFossilTimeBtn');
        const fossilTimeOutput = document.getElementById('fossilTimeOutput');
        const fossilTimeCanvas = document.getElementById('fossilTimeCanvas'); /* NEW Canvas */
        const fossilTimeCtx = fossilTimeCanvas.getContext('2d'); /* NEW Canvas */

        // NEW Cosmic Fossil Record Simulator (Advanced) elements (from user's snippet)
        const mass_fossil_adv_input = document.getElementById('mass_fossil_adv');
        const type_fossil_adv_select = document.getElementById('type_fossil_adv');
        const includeData_fossil_adv_checkbox = document.getElementById('includeData_fossil_adv');
        const simulateFossilsAdvancedBtn = document.getElementById('simulateFossilsAdvancedBtn');
        const fossilCanvasAdvanced = document.getElementById('fossilCanvasAdvanced');
        const fossilCtxAdvanced = fossilCanvasAdvanced.getContext('2d');
        const exportFossilDataAdvancedBtn = document.getElementById('exportFossilDataAdvancedBtn');
        const mass_fossil_adv_error_span = document.getElementById('mass_fossil_adv_error');
        let fossilPointsAdvanced = []; // Data storage for advanced fossil module


        // Physics Constants (Updated with more precision and clarity)
        const HBAR = 1.054571817e-34; // Reduced Planck constant (J·s)
        const C = 2.99792458e8;     // Speed of light (m/s)
        const KB = 1.380649e-23;    // Boltzmann constant (J/K)
        const G = 6.67430e-11;      // Gravitational constant (N·m²/kg²)
        const SOLAR_MASS = 1.98847e30; // Solar mass in kg (more precise)
        const PLANCK_LENGTH = 1.616255e-35; // Planck length (m)
        const PLANCK_MASS = 2.176434e-8; // Planck mass (kg)
        const PROTON_MASS = 1.6726219e-27; // Proton mass in kg (more precise)
        const H0_KM_S_MPC = 67.4;   // Hubble constant (km/s/Mpc) - used in main calculations
        const H0_PATCH_KM_S_MPC = 70; // Hubble constant for patch module (from provided snippet)
        const C_KM_S = 3e5; // Speed of light in km/s (from provided snippet)
        const MPC_TO_KM = 3.085677581491367e19; // Megaparsec to kilometers (more precise)
        const LIGHT_YEAR_TO_METERS = 9.461e15; // Light-year to meters (more precise)
        const SECONDS_PER_GYR = 3.154e16; // Seconds in a Gigayear

        // New Constants for Entropic and TOE modules
        const ENTROPY_DENSITY_UNIT = 1e40; // S0: Entropy density unit (conceptual)
        const LANDSCAPE_PARAMETER = 1e-5; // Conceptual parameter for decoherence (related to quantum fluctuations)


        // Simulation State Variables
        let currentSimulationMode = 'potential'; // 'potential', 'fossil', 'galactic', 'retraction'
        let isAnimating = false;
        let animationFrameId = null;
        let globalTime = 0; // NEW: Global simulation time in Gyr
        let phase = 0; // Phase for potential animation (now derived from globalTime and frequency)
        let dutFossilSimInstance = null; // To hold Fossil simulation results/state
        let galacticEvolutionSimInstance = null; // To hold Galactic simulation results/state
        let dutRetractionSimInstance = null; // To hold Retraction simulation results/state
        let currentPotentialResults = {}; // To store results for export
        window.currentRefutationData = null; // To store refutation data for export

        // ==========================================
        // Module: Utility Functions
        // ==========================================
        /**
         * Displays a temporary message to the user in a notification box.
         * @param {string} message - The message to display.
         * @param {string} type - 'info' for blue, 'error' for red, 'warning' for yellow/orange.
         * @param {number} duration - Duration in milliseconds (default: 3000).
         */
        function showMessage(message, type = 'info', duration = 3000) {
            messageBox.textContent = message;
            messageBox.className = `message-box ${type}`;
            messageBox.style.display = 'block';
            setTimeout(() => {
                messageBox.style.display = 'none';
            }, duration);
        }

        /**
         * Generic function to validate a numeric input field.
         * @param {HTMLInputElement} inputElement - The input field to validate.
         * @param {HTMLElement} errorElement - The span element to display error messages.
         * @param {string} fieldName - A human-readable name for the field.
         * @param {boolean} allowEmpty - If true, an empty field is considered valid.
         * @returns {boolean} True if the input is valid, false otherwise.
         */
        function validateNumericInput(inputElement, errorElement, fieldName, allowEmpty = false) {
            const value = parseFloat(inputElement.value);
            const min = parseFloat(inputElement.min);
            const max = parseFloat(inputElement.max);

            errorElement.textContent = ''; // Clear previous error
            inputElement.classList.remove('input-error');

            if (inputElement.value.trim() === '') {
                if (allowEmpty) return true;
                errorElement.textContent = `"${fieldName}" cannot be empty.`;
                inputElement.classList.add('input-error');
                return false;
            }
            if (isNaN(value)) {
                errorElement.textContent = `"${fieldName}" must be a valid number.`;
                inputElement.classList.add('input-error');
                return false;
            }
            if (value < min) {
                errorElement.textContent = `"${fieldName}" cannot be less than ${min}.`;
                inputElement.classList.add('input-error');
                return false;
            }
            if (!isNaN(max) && value > max) { // Check max only if it's a valid number
                errorElement.textContent = `"${fieldName}" cannot be greater than ${max}.`;
                inputElement.classList.add('input-error');
                return false;
            }
            return true;
        }

        /**
         * Exports simulation results to a CSV file.
         * @param {Array<Object>} data - Array of objects, each representing a row {key: value, ...}.
         * @param {string} filename - The name of the CSV file.
         * @param {string[]} headers - Optional array of column headers in desired order.
         */
        function exportToCSV(data, filename, headers = []) {
            if (!data || data.length === 0) {
                showMessage("No data to export!", "error");
                return;
            }

            let csv = '';
            // Determine headers: use provided or infer from first data object
            const actualHeaders = headers.length > 0 ? headers : Object.keys(data[0]);
            csv += actualHeaders.join(',') + '\n';

            // Add rows
            data.forEach(row => {
                const values = actualHeaders.map(header => {
                    const value = row[header];
                    // Handle numbers (e.g., scientific notation for very large/small numbers)
                    if (typeof value === 'number') {
                        // Use toPrecision for significant figures or toExponential for very large/small numbers
                        return value.toExponential(4);
                    }
                    // Escape commas and quotes in string values
                    if (typeof value === 'string' && (value.includes(',') || value.includes('"') || value.includes('\n'))) {
                        return `"${value.replace(/"/g, '""')}"`;
                    }
                    return value;
                });
                csv += values.join(',') + '\n';
            });

            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            if (link.download !== undefined) { // Feature detection for download attribute
                const url = URL.createObjectURL(blob);
                link.setAttribute('href', url);
                link.setAttribute('download', filename);
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                showMessage(`Data exported to ${filename}!`, "info");
            } else {
                showMessage("Your browser does not support downloading files.", "error");
            }
        }

        // ==========================================
        // Module: Physics Calculations (Improved)
        // ==========================================

        /**
         * Quantum potential correction (regularized for r -> 0)
         * Implements: ΔV_q(r) = (ħ²/2m) * [1 - exp(-r²/Lq²)] / (r² + Lq²)
         * Using Planck scales for Lq and m_eff for a conceptual quantum effect.
         * @param {number} r - Physical radial distance in meters.
         * @returns {number} The quantum correction potential.
         */
        function quantumPotentialCorrection(r) {
            // To prevent division by zero or extreme values near r=0,
            // we apply a small offset or return 0 for extremely small r.
            if (r < 1e-38) return 0; // Effectively zero for r much smaller than Planck length

            const Lq = PLANCK_LENGTH * 10; // A conceptual quantum length scale, e.g., 10 times Planck length
            const m_eff = PLANCK_MASS; // An effective mass, using Planck mass as a reference
            const r2 = r * r;
            const Lq2 = Lq * Lq;

            // Ensure the denominator doesn't become zero or too small relative to precision
            const denominator = r2 + Lq2;
            if (denominator === 0) return 0; // Fallback for edge case

            return (HBAR * HBAR) / (2 * m_eff) * (1 - Math.exp(-r2 / Lq2)) / denominator;
        }

        /**
         * Calculates the total gravitational potential (classical + quantum).
         * Corrected with Taylor approximation for small r to avoid singularities.
         * @param {number} r_norm - Normalized radial distance (unitless).
         * @param {number} current_phase - Dynamic phase for the oscillatory term (now time-dependent).
         * @param {number} V0 - Oscillation amplitude.
         * @param {number} alpha - Exponential decay rate.
         * @param {number} omega - Angular frequency.
         * @param {number} beta - Central potential coefficient.
         * @param {number} R_core_factor - Factor for R_core from slider (e.g., 1.0 for 1x10^28 m).
         * @returns {number} The calculated gravitational potential.
         */
        function calculateTotalPotential(r_norm, current_phase, V0, alpha, omega, beta, R_core_factor) {
            // Oscillatory term
            const oscTerm = V0 * Math.exp(-alpha * r_norm) * Math.cos(omega * r_norm + current_phase);

            // Central regularized term
            let centralTerm;
            if (Math.abs(r_norm) < 1e-6) { // Use Math.abs for symmetry around center
                // Taylor approximation for (1 - e^-r)/r as r -> 0: approx 1 - r/2 + r^2/6
                centralTerm = beta * (1 - Math.abs(r_norm) / 2 + (r_norm * r_norm) / 6);
            } else {
                centralTerm = beta * (1 - Math.exp(-Math.abs(r_norm))) / Math.abs(r_norm);
            }

            // Convert normalized distance to physical distance for quantum correction
            const R_core = R_core_factor * 1e28; // Physical core size in meters
            const r_physical = Math.abs(r_norm) * R_core; // Use absolute r for physical distance

            // Total potential is the sum of classical and quantum parts
            return oscTerm + centralTerm + quantumPotentialCorrection(r_physical);
        }

        /**
         * Calculates Core Temperature based on Virial Theorem (conceptual)
         * T ~ G * M * m / (k_B * R)
         * Where m is a characteristic particle mass (e.g., proton mass).
         * @param {number} M_core - Core mass in kg.
         * @param {number} R_core - Core radius in meters.
         * @returns {number} Core temperature in Kelvin.
         */
        function calculateCoreTemperature(M_core, R_core) {
            if (R_core <= 0) return 0; // Avoid division by zero
            return (G * M_core * PROTON_MASS) / (KB * R_core);
        }

        /**
         * Calculates Core Mass based on density and radius (conceptual).
         * M = (4/3) * pi * R^3 * rho
         * @param {number} R_core_factor - Core size factor from slider.
         * @param {number} rho_0_factor - Central density factor from slider.
         * @returns {number} Core mass in kg.
         */
        function calculateCoreMass(R_core_factor, rho_0_factor) {
            const R_core_meters = R_core_factor * 1e28; // R_core in meters
            const rho_0_kg_m3 = rho_0_factor * 1e-26; // Central density in kg/m^3
            return (4 / 3) * Math.PI * Math.pow(R_core_meters, 3) * rho_0_kg_m3;
        }

        /**
         * Corrected calculation of Omega_k (spatial curvature).
         * @param {number} R_core_factor - Core size factor from slider.
         * @param {number} rho_0_factor - Central density factor from slider.
         * @returns {number} The calculated spatial curvature (dimensionless).
         */
        function calculateSpatialCurvature(R_core_factor, rho_0_factor) {
            const H0_si = H0_KM_S_MPC * 1000 / MPC_TO_KM; // Convert H0 to s^-1
            const rho_crit = (3 * H0_si * H0_si) / (8 * Math.PI * G); // Critical density in kg/m^3

            const R_core_meters = R_core_factor * 1e28; // R_core in meters
            const rho_0_kg_m3 = rho_0_factor * 1e-26; // Central density in kg/m^3

            const volume_scaling_factor = Math.pow(R_core_meters / (C / H0_si), 3); // Ratio of core volume to Hubble volume
            if (volume_scaling_factor === 0) return 1;

            const effective_rho_contribution = rho_0_kg_m3 * volume_scaling_factor; // Conceptual local density contribution
            // Assuming Omega_k is derived from (total density - critical density) / critical density,
            // or 1 - (observed density / critical density) for an open/closed universe.
            // This is a conceptual interpretation for the DUT model based on local properties.
            return 1 - (effective_rho_contribution / rho_crit);
        }

        /**
         * Calculates the local entropic gradient ∇S(r,t) based on the gravitational potential.
         * Implementation: ∇S = - (dV/dr) * ρ(r,t)
         * ρ(r,t) decays exponentially with normalized radius and time.
         * @param {number} r_norm - Normalized radial distance.
         * @param {number} V0 - Oscillation amplitude.
         * @param {number} alpha - Exponential decay rate.
         * @param {number} omega - Angular frequency.
         * @param {number} beta - Central potential coefficient.
         * @param {number} current_phase - Dynamic phase for the oscillatory term.
         * @param {number} density_factor - Factor for initial density rho_0 from slider.
         * @param {number} entropy_evolution_rate - Rate of entropy evolution over time.
         * @param {number} sim_time - Current simulation time in Gyr.
         * @returns {number} The entropic gradient.
         */
        function entropyGradient(r_norm, V0, alpha, omega, beta, current_phase, density_factor, entropy_evolution_rate, sim_time) {
            const delta = 1e-5; // Small step for numerical derivative
            const R_core_factor = parseFloat(radiusSlider.value);
            const V_plus = calculateTotalPotential(r_norm + delta, current_phase, V0, alpha, omega, beta, R_core_factor);
            const V_minus = calculateTotalPotential(r_norm - delta, current_phase, V0, alpha, omega, beta, R_core_factor);
            const dVdr = (V_plus - V_minus) / (2 * delta);

            // Time-dependent density: conceptual decay over time
            const rho_r = calculateLocalDensity(r_norm, density_factor) * Math.exp(-entropy_evolution_rate * sim_time);

            return -dVdr * rho_r; // ∇S
        }

        /**
         * Calculates the local density based on normalized radius.
         * This function represents the T_matter component in a simplified scalar form.
         * @param {number} r_norm - Normalized radial distance.
         * @param {number} density_factor - Factor for initial density rho_0 from slider.
         * @returns {number} The local density (kg/m³).
         */
        function calculateLocalDensity(r_norm, density_factor) {
            const rho_0 = density_factor * 1e-26; // kg/m³
            // Exponential decay for density, use Math.abs for radial symmetry
            return rho_0 * Math.exp(-3 * Math.abs(r_norm));
        }

        /**
         * Regularized Metric Tensor Component g_tt (temporal part).
         * Models gravitational time dilation inside structural black hole without singularity.
         * Incorporates Thermodynamic Information Gravity coupling.
         * @param {number} r_norm - Normalized radial distance.
         * @param {number} V0 - Oscillation amplitude.
         * @param {number} alpha - Exponential decay rate.
         * @param {number} omega - Angular frequency.
         * @param {number} beta - Central potential coefficient.
         * @param {number} current_phase - Dynamic phase for the oscillatory term.
         * @param {number} R_core_factor - Factor for R_core from slider.
         * @param {number} thermo_gravity_factor - Coupling factor for thermodynamic gravity.
         * @param {number} density_factor - Factor for initial density rho_0 from slider.
         * @param {number} entropy_evolution_rate - Rate of entropy evolution over time.
         * @param {number} sim_time - Current simulation time in Gyr.
         * @returns {number} The g_tt metric component.
         */
        function metricGtt(r_norm, V0, alpha, omega, beta, current_phase, R_core_factor, thermo_gravity_factor, density_factor, entropy_evolution_rate, sim_time) {
            const V_total = calculateTotalPotential(r_norm, current_phase, V0, alpha, omega, beta, R_core_factor);
            const S_grad_squared = Math.pow(entropyGradient(r_norm, V0, alpha, omega, beta, current_phase, density_factor, entropy_evolution_rate, sim_time), 2);
            // Example: exponential deformation of metric component by total potential AND entropy gradient
            // This is a conceptual representation of delta G_munu ~ grad S grad S
            let gtt = Math.exp(-2 * V_total);
            // Additive term from thermodynamic information gravity (conceptual coupling)
            gtt -= thermo_gravity_factor * S_grad_squared;
            return gtt;
        }

        /**
         * Regularized Metric Tensor Component g_rr (radial part).
         * Avoids singularity at center by quantum-corrected potential.
         * Incorporates Thermodynamic Information Gravity coupling.
         * @param {number} r_norm - Normalized radial distance.
         * @param {number} V0 - Oscillation amplitude.
         * @param {number} alpha - Exponential decay rate.
         * @param {number} omega - Angular frequency.
         * @param {number} beta - Central potential coefficient.
         * @param {number} current_phase - Dynamic phase for the oscillatory term.
         * @param {number} R_core_factor - Factor for R_core from slider.
         * @param {number} thermo_gravity_factor - Coupling factor for thermodynamic gravity.
         * @param {number} density_factor - Factor for initial density rho_0 from slider.
         * @param {number} entropy_evolution_rate - Rate of entropy evolution over time.
         * @param {number} sim_time - Current simulation time in Gyr.
         * @returns {number} The g_rr metric component.
         */
        function metricGrr(r_norm, V0, alpha, omega, beta, current_phase, R_core_factor, thermo_gravity_factor, density_factor, entropy_evolution_rate, sim_time) {
            const V_total = calculateTotalPotential(r_norm, current_phase, V0, alpha, omega, beta, R_core_factor);
            const S_grad_squared = Math.pow(entropyGradient(r_norm, V0, alpha, omega, beta, current_phase, density_factor, entropy_evolution_rate, sim_time), 2);

            let denominator = (1 - 2 * G * V_total / (C * C));
            // Additive term from thermodynamic information gravity
            denominator += thermo_gravity_factor * S_grad_squared * (G / (C*C)); // Ensure unit consistency

            if (denominator <= 1e-10) { // Avoid division by zero or negative values
                return 1e15; // Represents extremely high curvature/resistance
            }
            return 1 / denominator;
        }

        /**
         * Quantum Vacuum Pressure Term near core.
         * Avoids infinite collapse as r -> 0. Represents a T_vacuum component.
         * @param {number} r_physical - Physical radial distance in meters.
         * @returns {number} The vacuum energy density (kg/m^3 equivalent or J/m^3).
         */
        function vacuumPressureCore(r_physical) {
            const Lq = PLANCK_LENGTH * 10;
            const rho_vacuum = (HBAR * C) / (Lq ** 4); // Conceptual vacuum energy density
            const denominator = 1 + Math.pow(r_physical / Lq, 2);
            return rho_vacuum / denominator;
        }

        /**
         * Entropy Layer Model.
         * Inner core has high entropy density, outer layers progressively lower. Represents a T_entropy component.
         * Now time-dependent based on entropy evolution rate.
         * @param {number} r_norm - Normalized radial distance.
         * @param {number} entropy_evolution_rate - Rate of entropy evolution over time.
         * @param {number} sim_time - Current simulation time in Gyr.
         * @returns {number} The entropy density (conceptual units, e.g., J/K/m^3 or dimensionless).
         */
        function entropyStratification(r_norm, entropy_evolution_rate, sim_time) {
            // Base spatial stratification
            let base_entropy = ENTROPY_DENSITY_UNIT * (1 - Math.exp(-5 * Math.abs(r_norm)));
            // Conceptual time evolution: entropy increases/decreases over time
            // For example, an exponential decay of maximum entropy over long times
            return base_entropy * Math.exp(-entropy_evolution_rate * sim_time);
        }

        /**
         * Local Proper Time dilation factor inside structural core.
         * dτ = sqrt(gtt) dt
         * @param {number} r_norm - Normalized radial distance.
         * @param {number} V0 - Oscillation amplitude.
         * @param {number} alpha - Exponential decay rate.
         * @param {number} omega - Angular frequency.
         * @param {number} beta - Central potential coefficient.
         * @param {number} current_phase - Dynamic phase for the oscillatory term.
         * @param {number} R_core_factor - Factor for R_core from slider.
         * @param {number} thermo_gravity_factor - Coupling factor for thermodynamic gravity.
         * @param {number} density_factor - Factor for initial density rho_0 from slider.
         * @param {number} entropy_evolution_rate - Rate of entropy evolution over time.
         * @param {number} sim_time - Current simulation time in Gyr.
         * @returns {number} The time dilation factor.
         */
        function properTimeDilation(r_norm, V0, alpha, omega, beta, current_phase, R_core_factor, thermo_gravity_factor, density_factor, entropy_evolution_rate, sim_time) {
            const gtt = metricGtt(r_norm, V0, alpha, omega, beta, current_phase, R_core_factor, thermo_gravity_factor, density_factor, entropy_evolution_rate, sim_time);
            // Ensure gtt is non-negative before sqrt
            if (gtt < 0) return 0; // Should not happen with Math.exp(-2*V_total) unless V_total is very complex
            return Math.sqrt(gtt);
        }

        /**
         * Conceptual Quantum Decoherence Rate.
         * Simulates loss of quantum coherence near the core due to gravitational interactions and thermal dissipation.
         * Depends on local density, temperature, and a conceptual "quantum landscape" parameter.
         * @param {number} r_physical - Physical radial distance in meters.
         * @param {number} core_temperature - Local core temperature (conceptual).
         * @param {number} local_density - Local matter density.
         * @param {number} decoherence_coupling_factor - Coupling factor from UI.
         * @returns {number} Decoherence rate in Hz (conceptual).
         */
        function calculateQuantumDecoherenceRate(r_physical, core_temperature, local_density, decoherence_coupling_factor) {
            // Simplified model: decoherence increases with density, temperature, and proximity to Planck scale physics
            // Inverse square dependency on Planck length (closer to quantum realm, more decoherence)
            const decoherence_base = (G / C) * (local_density * core_temperature); // Conceptual interaction term
            const distance_factor = Math.pow(PLANCK_LENGTH / (r_physical + PLANCK_LENGTH), 2); // Avoid division by zero
            return decoherence_base * distance_factor * LANDSCAPE_PARAMETER * decoherence_coupling_factor; // LANDSCAPE_PARAMETER is a tuning factor
        }


        /**
         * Generalized Stress-Energy Tensor Composition (Simplified scalar form).
         * This function conceptually combines energy densities from matter, vacuum, and entropy.
         * @param {number} r_norm - Normalized radial distance.
         * @param {number} V0 - Oscillation amplitude.
         * @param {number} alpha - Exponential decay rate.
         * @param {number} omega - Angular frequency.
         * @param {number} beta - Central potential coefficient.
         * @param {number} current_phase - Dynamic phase for the oscillatory term.
         * @param {number} R_core_factor - Factor for R_core from slider.
         * @param {number} density_factor - Factor for initial density rho_0 from slider.
         * @param {number} entropy_evolution_rate - Rate of entropy evolution over time.
         * @param {number} sim_time - Current simulation time in Gyr.
         * @returns {number} Total effective energy density (conceptual, in kg/m³ equivalent).
         */
        function totalStressEnergyTensor(r_norm, V0, alpha, omega, beta, current_phase, R_core_factor, density_factor, entropy_evolution_rate, sim_time) {
            const r_physical = Math.abs(r_norm) * (R_core_factor * 1e28); // Physical distance for vacuum term
            const T_matter_density = calculateLocalDensity(r_norm, density_factor) * Math.exp(-entropy_evolution_rate * sim_time); // Matter density can also evolve with entropy/time
            const T_vacuum_density = vacuumPressureCore(r_physical) / (C * C); // Convert J/m³ to kg/m³ using E=mc²
            const T_entropy_density = entropyStratification(r_norm, entropy_evolution_rate, sim_time) / (C * C * KB); // Very conceptual, convert entropy units to kg/m³

            // Sum up the densities. This is a highly simplified scalar representation
            // of a tensor sum, but serves the conceptual purpose for TOE precursor.
            return T_matter_density + T_vacuum_density + T_entropy_density;
        }

        // ==========================================
        // Module: Canvas Drawing
        // ==========================================
        /**
         * Draws the 1D gravitational potential curve, the entropic gradient, and related metrics.
         */
        function drawGravitationalMetricsAndEntropicFields() {
            ctx.clearRect(0, 0, mainCanvas.width, mainCanvas.height);

            // Get parameters from sliders
            const V0 = parseFloat(amplitudeSlider.value);
            const alpha = parseFloat(decaySlider.value);
            const omega = parseFloat(frequencySlider.value);
            const beta = parseFloat(centralSlider.value);
            const R_core_factor = parseFloat(radiusSlider.value);
            const rho_0_factor = parseFloat(densitySlider.value);
            const sim_time = parseFloat(simTimeSlider.value); // Get current simulation time
            const thermo_gravity_factor = parseFloat(thermoGravityFactorSlider.value);
            const entropy_evolution_rate = parseFloat(entropyEvolutionRateSlider.value);
            const decoherenceCouplingFactor = parseFloat(decoherenceCouplingFactorSlider.value);

            // Calculate current animation phase based on time
            const current_phase = phase + sim_time * 0.1; // Simple linear time dependency for visual evolution

            // Calculate results for display and export (at a representative point, e.g., r_norm = 1.0)
            const r_representative_norm = 1.0; // Point to display single values for
            const R_core_meters_for_calc = R_core_factor * 1e28;
            const M_core_kg = calculateCoreMass(R_core_factor, rho_0_factor);
            const T_core_K = calculateCoreTemperature(M_core_kg, R_core_meters_for_calc);
            const Omega_k = calculateSpatialCurvature(R_core_factor, rho_0_factor);

            const gtt_val = metricGtt(r_representative_norm, V0, alpha, omega, beta, current_phase, R_core_factor, thermo_gravity_factor, rho_0_factor, entropy_evolution_rate, sim_time);
            const grr_val = metricGrr(r_representative_norm, V0, alpha, omega, beta, current_phase, R_core_factor, thermo_gravity_factor, rho_0_factor, entropy_evolution_rate, sim_time);
            const proper_time_dilation_val = properTimeDilation(r_representative_norm, V0, alpha, omega, beta, current_phase, R_core_factor, thermo_gravity_factor, rho_0_factor, entropy_evolution_rate, sim_time);
            const total_stress_energy_val = totalStressEnergyTensor(r_representative_norm, V0, alpha, omega, beta, current_phase, R_core_factor, rho_0_factor, entropy_evolution_rate, sim_time);
            const local_density_at_Rcore = calculateLocalDensity(r_representative_norm, rho_0_factor) * Math.exp(-entropy_evolution_rate * sim_time); // Time-dependent
            const quantum_decoherence_rate_val = calculateQuantumDecoherenceRate(R_core_meters_for_calc, T_core_K, local_density_at_Rcore, decoherenceCouplingFactor);


            currentPotentialResults = {
                T_core: T_core_K,
                M_core: M_core_kg,
                Omega_k: Omega_k,
                V0: V0,
                alpha: alpha,
                omega: omega,
                beta: beta,
                R_core_factor: R_core_factor,
                rho_0_factor: rho_0_factor,
                sim_time: sim_time,
                thermo_gravity_factor: thermo_gravity_factor,
                entropy_evolution_rate: entropy_evolution_rate,
                decoherence_coupling_factor: decoherenceCouplingFactor,
                gtt_at_Rcore: gtt_val,
                grr_at_Rcore: grr_val,
                proper_time_dilation_at_Rcore: proper_time_dilation_val,
                quantum_decoherence_rate_at_Rcore: quantum_decoherence_rate_val,
                total_stress_energy_at_Rcore: total_stress_energy_val
            };

            potentialResultsDiv.innerHTML = `
                T<sub>core</sub> &asymp; ${T_core_K.toExponential(2)} K<br>
                M<sub>core</sub> &asymp; ${(M_core_kg / SOLAR_MASS).toExponential(2)} solar masses<br>
                &Omega;<sub>k</sub> &asymp; ${Omega_k.toFixed(5)}<br>
                g<sub>tt</sub> (at R<sub>core</sub>, t) &asymp; ${gtt_val.toFixed(4)} <br>
                g<sub>rr</sub> (at R<sub>core</sub>, t) &asymp; ${grr_val.toExponential(2)} <br>
                Proper Time Dilation Factor (at R<sub>core</sub>, t) &asymp; ${proper_time_dilation_val.toFixed(4)} <br>
                Conceptual Quantum Decoherence Rate (at R<sub>core</sub>, t) &asymp; ${quantum_decoherence_rate_val.toExponential(2)} Hz<br>
                Total Stress-Energy Density (at R<sub>core</sub>, t) &asymp; ${total_stress_energy_val.toExponential(2)} kg/m³
            `;

            const centerX = mainCanvas.width / 2;
            const centerY = mainCanvas.height / 2;
            const scaleX = mainCanvas.width / 20; // 20 units wide (from -10 to 10 normalized)
            const potentialScaleY = mainCanvas.height / 4; // Scale for potential values (V values)
            const entropyScaleY = mainCanvas.height / 50; // Scale for entropy gradient values (∇S values), adjust as needed
            const properTimeScaleY = mainCanvas.height / 10; // Scale for proper time dilation values (Δτ values), adjust as needed

            // Draw grid
            ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--grid-color');
            ctx.lineWidth = 0.5;
            for (let i = -10; i <= 10; i += 1) { // Vertical grid lines
                ctx.beginPath();
                ctx.moveTo(centerX + i * scaleX, 0);
                ctx.lineTo(centerX + i * scaleX, mainCanvas.height);
                ctx.stroke();
            }
            for (let i = -2; i <= 2; i += 0.5) { // Horizontal grid lines for Potential
                ctx.beginPath();
                ctx.moveTo(0, centerY - i * potentialScaleY / 2);
                ctx.lineTo(mainCanvas.width, centerY - i * potentialScaleY / 2);
                ctx.stroke();
            }

            // Draw axes
            ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--axis-color');
            ctx.lineWidth = 1.5;
            // X-axis
            ctx.beginPath();
            ctx.moveTo(0, centerY);
            ctx.lineTo(centerX * 2, centerY); /* Use centerX * 2 for full width */
            ctx.stroke();
            // Y-axis
            ctx.beginPath();
            ctx.moveTo(centerX, 0);
            ctx.lineTo(centerX, mainCanvas.height);
            ctx.stroke();

            // Draw potential curve
            ctx.beginPath();
            ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--highlight-color');
            ctx.lineWidth = 2;

            const numPoints = mainCanvas.width;
            for (let i = 0; i < numPoints; i++) {
                const r_norm = (i - centerX) / scaleX; // Normalized radial distance
                const potential = calculateTotalPotential(r_norm, current_phase, V0, alpha, omega, beta, R_core_factor);

                const x = i;
                const y = centerY - potential * potentialScaleY; // Invert Y for canvas coordinates

                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.stroke();

            // Draw entropic gradient curve
            ctx.beginPath();
            ctx.strokeStyle = '#FFD700'; // Gold color for entropy gradient
            ctx.lineWidth = 1.5;

            let maxEntropyGrad = -Infinity;
            let minEntropyGrad = Infinity;
            let maxEntropyGradX = 0;
            let minEntropyGradX = 0;

            for (let i = 0; i < numPoints; i++) {
                const r_norm = (i - centerX) / scaleX; // Normalized radial distance
                const entropy_grad = entropyGradient(r_norm, V0, alpha, omega, beta, current_phase, rho_0_factor, entropy_evolution_rate, sim_time);

                const x = i;
                const y = centerY - entropy_grad * entropyScaleY;

                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }

                if (entropy_grad > maxEntropyGrad) {
                    maxEntropyGrad = entropy_grad;
                    maxEntropyGradX = x;
                }
                if (entropy_grad < minEntropyGrad) {
                    minEntropyGrad = entropy_grad;
                    minEntropyGradX = x;
                }
            }
            ctx.stroke();

            // Draw Proper Time Dilation curve (NEW: Metric Topography)
            ctx.beginPath();
            ctx.strokeStyle = '#00FFFF'; // Cyan color for proper time dilation
            ctx.lineWidth = 1.5;

            let minProperTimeDilation = Infinity;
            let minProperTimeDilationX = 0;
            let maxProperTimeDilation = -Infinity;
            let maxProperTimeDilationX = 0;

            for (let i = 0; i < numPoints; i++) {
                const r_norm = (i - centerX) / scaleX;
                const proper_time_dilation = properTimeDilation(r_norm, V0, alpha, omega, beta, current_phase, R_core_factor, thermo_gravity_factor, rho_0_factor, entropy_evolution_rate, sim_time);

                const x = i;
                const y = centerY - proper_time_dilation * properTimeScaleY; // Scale for display

                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }

                // Identify extrema for "surfaces of stagnation"
                if (proper_time_dilation < minProperTimeDilation) {
                    minProperTimeDilation = proper_time_dilation;
                    minProperTimeDilationX = x;
                }
                if (proper_time_dilation > maxProperTimeDilation) {
                    maxProperTimeDilation = proper_time_dilation;
                    maxProperTimeDilationX = x;
                }
            }
            ctx.stroke();

            // Draw Causal Boundary
            drawCausalBoundary(ctx, centerX, scaleX, rho_0_factor);

            // Draw markers for "surfaces of stagnation" (extrema of proper time dilation)
            ctx.fillStyle = '#FF4500'; // Orange-red color
            ctx.beginPath();
            ctx.arc(minProperTimeDilationX, centerY - minProperTimeDilation * properTimeScaleY, 5, 0, 2 * Math.PI);
            ctx.fill();
            ctx.fillText("Min Proper Time", minProperTimeDilationX + 7, centerY - minProperTimeDilation * properTimeScaleY);

            ctx.beginPath();
            ctx.arc(maxProperTimeDilationX, centerY - maxProperTimeDilation * properTimeScaleY, 5, 0, 2 * Math.PI);
            ctx.fill();
            ctx.fillText("Max Proper Time", maxProperTimeDilationX + 7, centerY - maxProperTimeDilation * properTimeScaleY);

            // Draw markers for extrema of entropy gradient (conceptual entropy maxima surfaces)
            ctx.fillStyle = '#FFFF00'; // Yellow
            ctx.beginPath();
            ctx.arc(maxEntropyGradX, centerY - maxEntropyGrad * entropyScaleY, 5, 0, 2 * Math.PI);
            ctx.fill();
            ctx.fillText("Max Entropy Grad.", maxEntropyGradX + 7, centerY - maxEntropyGrad * entropyScaleY - 10);

            ctx.beginPath();
            ctx.arc(minEntropyGradX, centerY - minEntropyGrad * entropyScaleY, 5, 0, 2 * Math.PI);
            ctx.fill();
            ctx.fillText("Min Entropy Grad.", minEntropyGradX + 7, centerY - minEntropyGrad * entropyScaleY + 10);
        }

        /**
         * Draws the "causal boundary" where density becomes negligible.
         * @param {CanvasRenderingContext2D} ctx - The canvas rendering context.
         * @param {number} centerX - The x-coordinate of the center of the canvas.
         * @param {number} scaleX - The scale factor for x-axis (pixels per normalized unit).
         * @param {number} density_factor - Factor for initial density rho_0 from slider.
         */
        function drawCausalBoundary(ctx, centerX, scaleX, density_factor) {
            ctx.strokeStyle = '#FF0000'; // Red color for boundary
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]); // Dashed line

            const threshold_percentage = 0.01; // 1% of initial density
            // Find r_norm where density drops below threshold (rho_r = rho_0 * exp(-3 * r_norm))
            // threshold_percentage * rho_0 = rho_0 * exp(-3 * r_norm)
            // threshold_percentage = exp(-3 * r_norm)
            // r_norm = -Math.log(threshold_percentage) / 3
            const r_boundary_norm = -Math.log(threshold_percentage) / 3;

            // Convert normalized distance to canvas coordinates
            const boundaryX_positive = centerX + r_boundary_norm * scaleX;
            const boundaryX_negative = centerX - r_boundary_norm * scaleX;

            ctx.beginPath();
            ctx.moveTo(boundaryX_positive, 0);
            ctx.lineTo(boundaryX_positive, ctx.canvas.height);
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(boundaryX_negative, 0);
            ctx.lineTo(boundaryX_negative, ctx.canvas.height);
            ctx.stroke();

            ctx.setLineDash([]); // Reset line dash
            ctx.fillStyle = '#FF0000';
            ctx.font = '12px Arial';
            ctx.textAlign = 'left';
            ctx.fillText('Causal Boundary', boundaryX_positive + 5, 20);
            ctx.textAlign = 'right';
            ctx.fillText('Causal Boundary', boundaryX_negative - 5, 20);
            ctx.textAlign = 'center'; // Reset to default
        }


        /**
         * Animation loop for gravitational potential and entropic gradient.
         */
        function animateGravitationalMetricsAndEntropicFields() {
            if (!isAnimating) {
                // Ensure animation frame is cancelled if animation stops
                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                    animationFrameId = null;
                }
                return;
            }
            phase += 0.05; // Increment visual phase for oscillation animation
            globalTime += 0.1; // Increment conceptual global time
            if (globalTime > parseFloat(simTimeSlider.max)) { // Loop global time
                globalTime = parseFloat(simTimeSlider.min);
            }
            simTimeSlider.value = globalTime; // Update slider
            simTimeValSpan.textContent = globalTime.toFixed(1); // Update slider value span

            drawGravitationalMetricsAndEntropicFields();
            animationFrameId = requestAnimationFrame(animateGravitationalMetricsAndEntropicFields);
        }

        // ==========================================
        // Module: Cosmic Fossil Record Simulation
        // ==========================================
        class DUTFossilSimulator {
            constructor(t0, t_max, dt, beta) {
                this.t0 = t0;
                this.t_max = t_max;
                this.dt = dt;
                this.beta = beta; // Population decay rate
                this.results = [];
                this.finalResults = {};
            }

            validateParams() {
                const errors = [];
                if (this.t0 <= 0) errors.push("Initial Time (t₀) must be positive.");
                if (this.t_max <= this.t0) errors.push("Max Time (tmax) must be greater than Initial Time (t₀).");
                if (this.dt <= 0) errors.push("Time Step (dt) must be positive.");
                if (this.beta <= 0) errors.push("Population Decay Rate (β) must be positive.");
                return errors;
            }

            runSimulation() {
                const errors = this.validateParams();
                if (errors.length > 0) {
                    throw new Error(errors.join("\n"));
                }

                this.results = [];
                let currentTime = this.t0;
                let currentEnergy = 1.0; // Normalized initial usable energy
                let currentColdGas = 1.0; // Normalized initial cold gas mass

                // Simplified decay model for demonstration
                while (currentTime <= this.t_max && currentEnergy > 0.001) { // Simulate until energy is very low
                    currentEnergy = Math.exp(-this.beta * (currentTime - this.t0));
                    // Conceptual evolution for cold gas: decays slower or differently
                    currentColdGas = Math.exp(-this.beta / 2 * (currentTime - this.t0));

                    this.results.push({
                        time: currentTime,
                        usable_energy: currentEnergy,
                        cold_gas_mass: currentColdGas
                    });
                    currentTime += this.dt;
                }

                this.finalResults = {
                    extinction_time: currentTime,
                    final_usable_energy: currentEnergy,
                    final_cold_gas_mass: currentColdGas
                };
                return this.finalResults;
            }

            displayResults() {
                if (!this.finalResults.extinction_time) {
                    fossilResultsDiv.innerHTML = "Run the simulation first to see the results.";
                    return;
                }
                fossilResultsDiv.innerHTML = `
                    Estimated Cosmic Energy Extinction Time: ${this.finalResults.extinction_time.toFixed(2)} Gyr<br>
                    Final Usable Energy: ${this.finalResults.final_usable_energy.toExponential(2)} (Normalized Units)<br>
                    Final Cold Gas Mass: ${this.finalResults.final_cold_gas_mass.toExponential(2)} (Normalized Units)<br><br>
                    Calculated Cosmic Time at Redshift:<br>
                    ${fossilTimeOutput.textContent}
                `;
            }

            getCSVData() {
                return this.results.map(r => ({
                    Time_Gyr: r.time,
                    Usable_Energy: r.usable_energy,
                    Cold_Gas_Mass: r.cold_gas_mass
                }));
            }
        }

        // ==========================================
        // Module: Galactic Evolution Simulation (RK4 Implemented)
        // ==========================================
        class GalacticEvolutionSimulator {
            constructor(alpha, N0, Nf_dot, total_time, dt) {
                this.alpha = alpha; // Quenching rate (Gyr⁻¹)
                this.N0 = N0;       // Initial Active Galaxies
                this.Nf_dot = Nf_dot; // New Galaxy Formation Rate (galaxies/Gyr)
                this.total_time = total_time;
                this.dt = dt;
                this.results = [];
                this.finalResults = {};
            }

            validateParams() {
                const errors = [];
                if (this.alpha <= 0) errors.push("Quenching Rate (α) must be positive.");
                if (this.N0 < 0) errors.push("Initial Active Galaxies (N₀) cannot be negative.");
                if (this.Nf_dot < 0) errors.push("New Galaxy Formation Rate (Ṅf) cannot be negative.");
                if (this.total_time <= 0) errors.push("Total Simulation Time must be positive.");
                if (this.dt <= 0) errors.push("Time Step (dt) must be positive.");
                if (this.dt > this.total_time) errors.push("Time Step (dt) cannot be greater than Total Simulation Time.");
                return errors;
            }

            /**
             * The differential equation for galaxy population: dN/dt = Nf_dot - alpha * N
             * @param {number} N - Current number of active galaxies.
             * @returns {number} The rate of change of N with respect to t.
             */
            dNdt(N) {
                // The differential equation only depends on N, not explicitly on t for this model
                return this.Nf_dot - this.alpha * N;
            }

            runSimulation() {
                const errors = this.validateParams();
                if (errors.length > 0) {
                    throw new Error(errors.join("\n"));
                }

                this.results = [];
                let currentN = this.N0;
                let t = 0;

                this.results.push({ time: t, active_galaxies: currentN });

                while (t < this.total_time) {
                    // RK4 method for dN/dt = f(N)
                    const k1 = this.dt * this.dNdt(currentN);
                    const k2 = this.dt * this.dNdt(currentN + k1 / 2);
                    const k3 = this.dt * this.dNdt(currentN + k2 / 2);
                    const k4 = this.dt * this.dNdt(currentN + k3);

                    currentN = currentN + (k1 + 2 * k2 + 2 * k3 + k4) / 6;

                    t += this.dt;
                    if (t > this.total_time) t = this.total_time; // Cap at total_time for last step

                    // Ensure galaxy count doesn't go negative
                    if (currentN < 0) currentN = 0;

                    this.results.push({ time: t, active_galaxies: currentN });
                }

                this.finalResults = {
                    initial_active_galaxies: this.N0,
                    final_active_galaxies: currentN,
                    total_simulation_time: this.total_time
                };
                return this.finalResults;
            }

            displayResults() {
                if (!this.finalResults.final_active_galaxies && this.finalResults.final_active_galaxies !== 0) {
                    galacticResultsDiv.innerHTML = "Run the simulation first to see the results.";
                    return;
                }
                galacticResultsDiv.innerHTML = `
                    Initial Active Galaxies: ${this.finalResults.initial_active_galaxies.toLocaleString()}<br>
                    Final Active Galaxies: ${Math.round(this.finalResults.final_active_galaxies).toLocaleString()}
                `;
                // Draw the plot using the original canvas
                drawGalacticEvolutionPlotOriginal(this.results);
            }

            getCSVData() {
                return this.results.map(r => ({
                    Time_Gyr: r.time,
                    Active_Galaxies: r.active_galaxies
                }));
            }
        }

        /**
         * Draws the Galactic Evolution Plot for the original module.
         * @param {Array<Object>} data - Array of {time, active_galaxies} objects.
         */
        function drawGalacticEvolutionPlotOriginal(data) {
            galacticEvolutionCtxOriginal.clearRect(0, 0, galacticEvolutionCanvasOriginal.width, galacticEvolutionCanvasOriginal.height);

            const margin = 30;
            const plotWidth = galacticEvolutionCanvasOriginal.width - 2 * margin;
            const plotHeight = galacticEvolutionCanvasOriginal.height - 2 * margin;

            let maxN = 0;
            let maxT = 0;
            if (data.length > 0) {
                maxN = Math.max(...data.map(d => d.active_galaxies));
                maxT = Math.max(...data.map(d => d.time));
            }
            maxN = Math.max(maxN, 1); // Ensure min scale
            maxT = Math.max(maxT, 1); // Ensure min scale

            // Draw axes
            galacticEvolutionCtxOriginal.strokeStyle = varCss('--axis-color');
            galacticEvolutionCtxOriginal.lineWidth = 1;
            galacticEvolutionCtxOriginal.beginPath();
            galacticEvolutionCtxOriginal.moveTo(margin, galacticEvolutionCanvasOriginal.height - margin); // X-axis
            galacticEvolutionCtxOriginal.lineTo(galacticEvolutionCanvasOriginal.width - margin, galacticEvolutionCanvasOriginal.height - margin);
            galacticEvolutionCtxOriginal.moveTo(margin, galacticEvolutionCanvasOriginal.height - margin); // Y-axis
            galacticEvolutionCtxOriginal.lineTo(margin, margin);
            galacticEvolutionCtxOriginal.stroke();

            // Draw labels
            galacticEvolutionCtxOriginal.fillStyle = varCss('--text-color-secondary');
            galacticEvolutionCtxOriginal.font = '10px Arial';
            galacticEvolutionCtxOriginal.textAlign = 'center';
            galacticEvolutionCtxOriginal.fillText('Time (Gyr)', galacticEvolutionCanvasOriginal.width / 2, galacticEvolutionCanvasOriginal.height - 5);
            galacticEvolutionCtxOriginal.save();
            galacticEvolutionCtxOriginal.translate(15, galacticEvolutionCanvasOriginal.height / 2);
            galacticEvolutionCtxOriginal.rotate(-Math.PI / 2);
            galacticEvolutionCtxOriginal.fillText('Active Galaxies (N)', 0, 0);
            galacticEvolutionCtxOriginal.restore();

            // X-axis ticks (time)
            for (let i = 0; i <= 4; i++) {
                const tTick = (i / 4) * maxT;
                const x = margin + (tTick / maxT) * plotWidth;
                galacticEvolutionCtxOriginal.fillText(tTick.toFixed(0), x, galacticEvolutionCanvasOriginal.height - margin + 15);
            }

            // Y-axis ticks (galaxy count)
            for (let i = 0; i <= 5; i++) {
                const nTickVal = (i / 5) * maxN;
                const y = galacticEvolutionCtxOriginal.height - margin - (i / 5) * plotHeight;
                galacticEvolutionCtxOriginal.fillText(nTickVal.toExponential(0), margin - 10, y + 3);
            }

            galacticEvolutionCtxOriginal.beginPath();
            galacticEvolutionCtxOriginal.strokeStyle = '#00c6fb'; // Blue for galaxy evolution curve
            galacticEvolutionCtxOriginal.lineWidth = 2;

            data.forEach((point, i) => {
                const xPos = margin + (point.time / maxT) * plotWidth;
                const yPos = galacticEvolutionCtxOriginal.height - margin - (point.active_galaxies / maxN) * plotHeight;

                if (i === 0) galacticEvolutionCtxOriginal.moveTo(xPos, yPos);
                else galacticEvolutionCtxOriginal.lineTo(xPos, yPos);
            });
            galacticEvolutionCtxOriginal.stroke();
            galacticEvolutionPlotInfoOriginal.textContent = `Galaxy Population Plot: (x-axis: time in Gyr, y-axis: active galaxies)`;
        }


        // ==========================================
        // Module: Thermodynamic Retraction Simulation (NEW)
        // ==========================================
        class DUTRetractionSimulator {
            constructor(t_max, dt, beta_retraction) {
                this.t_max = t_max;
                this.dt = dt;
                this.beta_retraction = beta_retraction; // Retraction factor (global infertility)
                this.results = [];
                this.finalResults = {};
            }

            validateParams() {
                const errors = [];
                if (this.t_max <= 0) errors.push("Max Time (tmax) must be positive.");
                if (this.dt <= 0) errors.push("Time Step (dt) must be positive.");
                if (this.beta_retraction <= 0) errors.push("Retraction Factor (β_retraction) must be positive.");
                return errors;
            }

            runSimulation() {
                const errors = this.validateParams();
                if (errors.length > 0) {
                    throw new Error(errors.join("\n"));
                }

                this.results = [];
                let volume = 1.0;  // Initial normalized observable volume
                let time = 0;

                while (time <= this.t_max) {
                    // Retraction modeled logistically with beta_retraction as a global infertility factor
                    // volume = 1 / (1 + beta * time)
                    volume = 1 / (1 + this.beta_retraction * time);
                    this.results.push({time: time, volume: volume}); // Use 'this.results'
                    time += this.dt;
                }

                this.finalResults = {
                    total_time: this.t_max,
                    final_observable_volume: volume
                };
                return this.finalResults;
            }

            displayResults() {
                if (!this.finalResults.final_observable_volume && this.finalResults.final_observable_volume !== 0) {
                    retractionResultsDiv.innerHTML = "Run the simulation first to see the results.";
                    return;
                }
                retractionResultsDiv.innerHTML = `
                    Total Simulated Time: ${this.finalResults.total_time.toFixed(1)} Gyr<br>
                    Final Observable Volume: ${this.finalResults.final_observable_volume.toExponential(2)} (Normalized)
                `;
                drawRetractionPlot(); // Draw the plot after simulation
            }

            getCSVData() {
                return this.results.map(r => ({
                    Time_Gyr: r.time,
                    Observable_Volume: r.volume
                }));
            }
        }

        /**
         * Draws the Thermodynamic Retraction Plot.
         */
        function drawRetractionPlot() {
            retractionCtx.clearRect(0, 0, retractionCanvas.width, retractionCanvas.height);

            const margin = 30;
            const plotWidth = retractionCanvas.width - 2 * margin;
            const plotHeight = retractionCanvas.height - 2 * margin;

            const t_max = parseFloat(retraction_tmax_input.value);
            const beta_retraction = parseFloat(retraction_beta_input.value);

            // Max Y value (normalized volume starts at 1.0)
            const maxY = 1.0;

            // Draw axes
            retractionCtx.strokeStyle = varCss('--axis-color');
            retractionCtx.lineWidth = 1;
            retractionCtx.beginPath();
            retractionCtx.moveTo(margin, retractionCanvas.height - margin); // X-axis
            retractionCtx.lineTo(retractionCanvas.width - margin, retractionCanvas.height - margin);
            retractionCtx.moveTo(margin, retractionCanvas.height - margin); // Y-axis
            retractionCtx.lineTo(margin, margin);
            retractionCtx.stroke();

            // Draw labels
            retractionCtx.fillStyle = varCss('--text-color-secondary');
            retractionCtx.font = '10px Arial';
            retractionCtx.textAlign = 'center';
            retractionCtx.fillText('Time (Gyr)', retractionCanvas.width / 2, retractionCanvas.height - 5);
            retractionCtx.save();
            retractionCtx.translate(15, retractionCanvas.height / 2);
            retractionCtx.rotate(-Math.PI / 2);
            retractionCtx.fillText('Normalized Observable Volume', 0, 0);
            retractionCtx.restore();

            // X-axis ticks (time)
            for (let i = 0; i <= 4; i++) { // 0, 1/4, 1/2, 3/4, 1 of t_max
                const tTick = (i / 4) * t_max;
                const x = margin + (tTick / t_max) * plotWidth;
                retractionCtx.fillText(tTick.toFixed(0), x, retractionCanvas.height - margin + 15);
            }

            // Y-axis ticks (volume)
            for (let i = 0; i <= 5; i++) { // 0, 0.2, 0.4, ..., 1.0
                const vTickVal = (i / 5) * maxY;
                const y = retractionCanvas.height - margin - (i / 5) * plotHeight;
                retractionCtx.fillText(vTickVal.toFixed(1), margin - 10, y + 3);
            }

            retractionCtx.beginPath();
            retractionCtx.strokeStyle = '#FF6347'; // Tomato color for retraction curve
            retractionCtx.lineWidth = 2;

            const numPoints = 100;
            for (let i = 0; i <= numPoints; i++) {
                const t = (i / numPoints) * t_max;
                const volume = 1 / (1 + beta_retraction * t);

                const xPos = margin + (t / t_max) * plotWidth;
                const yPos = retractionCanvas.height - margin - (volume / maxY) * plotHeight;

                if (i === 0) retractionCtx.moveTo(xPos, yPos);
                else retractionCtx.lineTo(xPos, yPos);
            }
            retractionCtx.stroke();
            retractionPlotInfo.textContent = `Observable Volume Plot: (x-axis: time in Gyr, y-axis: normalized volume)`;
        }


        // ==========================================
        // Module: Observational Data API (Simulated and Conceptual for Future Real Expansion)
        // ==========================================
        const ObservationalAPI = {
            /**
             * Simulated API call to JWST for early galaxy data.
             * Enhanced with more diverse data points for stellar mass and redshifts.
             */
            getJWSTGalaxyData: function() {
                return [
                    { name: "JWST-CEERS-1019", redshift: 8.68, stellar_mass_solar: 1.2e9, sSFR_yr_inv: 1.5e-10, morphology: "Disk" },
                    { name: "JWST-GLASS-z13", redshift: 13.1, stellar_mass_solar: 1.8e8, sSFR_yr_inv: 2.1e-9, morphology: "Compact" },
                    { name: "JWST-JADES-GS-z13-0", redshift: 13.2, stellar_mass_solar: 1.5e9, sSFR_yr_inv: 8.9e-11, morphology: "Irregular" },
                    { name: "JWST-JADES-GS-z12-0", redshift: 12.0, stellar_mass_solar: 2.1e9, sSFR_yr_inv: 1.1e-10, morphology: "Elliptical-like" },
                    { name: "JWST-PRIMER-Z9", redshift: 9.3, stellar_mass_solar: 5.5e8, sSFR_yr_inv: 7.2e-10, morphology: "Disk" },
                    { name: "JWST-MAST-z11", redshift: 11.5, stellar_mass_solar: 9.1e7, sSFR_yr_inv: 3.0e-9, morphology: "Compact" },
                    { name: "JWST-COSMOS-z10", redshift: 10.1, stellar_mass_solar: 3.2e9, sSFR_yr_inv: 9.5e-11, morphology: "Irregular" }
                ];
            },

            /**
             * Simulated API call to NASA Earth observation data.
             * Enhanced with more diverse data points.
             */
            getNASAEarthData: function() {
                return {
                    "last_updated": "2025-07-11",
                    "avg_temp_change_since_1900_C": 1.25,
                    "avg_sea_level_rise_mm_yr": 3.6,
                    "co2_concentration_ppm": 427.1,
                    "arctic_sea_ice_extent_km2": 4.1e6, /* Simulated September min */
                    "antarctic_sea_ice_extent_km2": 18.0e6, /* Simulated February max */
                    "global_forest_loss_km2_yr": 120000,
                    "major_volcanic_eruptions_past_year": [
                        { name: "Mt. Stromboli", date: "2025-01-15", type: "Explosive" },
                        { name: "Kilauea", date: "2024-11-01", type: "Effusive" }
                    ]
                };
            },

            // New simulated data representing generic stellar population or star formation rate (SFR) curves
            getSimulatedStarFormationRates: function() {
                // Returns an array of objects, each with time (Gyr) and SFR (solar masses/year)
                return [
                    { time_gyr: 0.1, sfr_solar_mass_yr: 100 },
                    { time_gyr: 0.5, sfr_solar_mass_yr: 80 },
                    { time_gyr: 1.0, sfr_solar_mass_yr: 60 },
                    { time_gyr: 2.0, sfr_solar_mass_yr: 40 },
                    { time_gyr: 5.0, sfr_solar_mass_yr: 20 },
                    { time_gyr: 8.0, sfr_solar_mass_yr: 10 },
                    { time_gyr: 10.0, sfr_solar_mass_yr: 5 },
                    { time_gyr: 12.0, sfr_solar_mass_yr: 2 },
                    { time_gyr: 13.0, sfr_solar_mass_yr: 1.5 },
                    { time_gyr: 13.8, sfr_solar_mass_yr: 1 }
                ];
            }
        };


        // ==========================================
        // Module: Local Scientific Ledger (with real SHA-256)
        // ==========================================
        const LOCAL_LEDGER_KEY = 'dut_scientific_ledger';

        /**
         * Calculates SHA-256 hash using Web Crypto API.
         * @param {string} str - The input string to hash.
         * @returns {Promise<string>} A promise that resolves with the SHA-256 hash in hex format.
         */
        async function sha256(str) {
            const textEncoder = new TextEncoder();
            const data = textEncoder.encode(str);
            const hashBuffer = await crypto.subtle.digest('SHA-256', data);
            const hashArray = Array.from(new Uint8Array(hashBuffer));
            const hexHash = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
            return hexHash;
        }

        /**
         * Records current simulation data to the local ledger.
         */
        async function recordCurrentDataToLedger() {
            try {
                let ledger = JSON.parse(localStorage.getItem(LOCAL_LEDGER_KEY)) || [];
                const timestamp = new Date().toISOString();
                const privacySetting = recordPrivacySelect.value;
                let dataToRecord;

                // Capture data based on the current active simulation mode
                if (currentSimulationMode === 'potential') {
                    if (Object.keys(currentPotentialResults).length === 0) {
                        showMessage("No Gravitational Potential simulation data available to record. Please adjust parameters or run the simulation first.", "error", 5000);
                        return;
                    }
                    dataToRecord = {
                        mode: 'Gravitational Potential',
                        params: {
                            V0: parseFloat(amplitudeSlider.value),
                            omega: parseFloat(frequencySlider.value),
                            alpha: parseFloat(decaySlider.value),
                            beta: parseFloat(centralSlider.value),
                            R_core_factor: parseFloat(radiusSlider.value),
                            rho_0_factor: parseFloat(densitySlider.value),
                            sim_time: parseFloat(simTimeSlider.value),
                            thermo_gravity_factor: parseFloat(thermoGravityFactorSlider.value),
                            entropy_evolution_rate: parseFloat(entropyEvolutionRateSlider.value),
                            decoherence_coupling_factor: parseFloat(decoherenceCouplingFactorSlider.value)
                        },
                        results: currentPotentialResults
                    };
                } else if (currentSimulationMode === 'fossil' && dutFossilSimInstance && dutFossilSimInstance.finalResults && Object.keys(dutFossilSimInstance.finalResults).length > 0) {
                    dataToRecord = {
                        mode: 'Cosmic Fossil Record',
                        params: {
                            t0: parseFloat(fossil_t0_input.value),
                            t_max: parseFloat(fossil_tmax_input.value),
                            dt: parseFloat(fossil_dt_input.value),
                            beta: parseFloat(fossil_beta_input.value),
                            z_fossil: parseFloat(z_fossil_newInput.value) /* Include new z param */
                        },
                        results: {
                            ...dutFossilSimInstance.finalResults,
                            calculated_cosmic_time_at_z: fossilTimeOutput.textContent /* Include new time result */
                        }
                    };
                } else if (currentSimulationMode === 'galactic' && galacticEvolutionSimInstance && galacticEvolutionSimInstance.finalResults && Object.keys(galacticEvolutionSimInstance.finalResults).length > 0) {
                    dataToRecord = {
                        mode: 'Galactic Evolution',
                        params: {
                            alpha: parseFloat(galactic_alpha_input.value),
                            N0: parseFloat(galactic_N0_input.value),
                            Nf_dot: parseFloat(galactic_Nf_dot_input.value),
                            total_time: parseFloat(galactic_total_time_input.value),
                            dt: parseFloat(galactic_dt_input.value)
                        },
                        results: galacticEvolutionSimInstance.finalResults
                    };
                } else if (currentSimulationMode === 'retraction' && dutRetractionSimInstance && dutRetractionSimInstance.finalResults && Object.keys(dutRetractionSimInstance.finalResults).length > 0) {
                     dataToRecord = {
                        mode: 'Thermodynamic Retraction',
                        params: {
                            t_max: parseFloat(retraction_tmax_input.value),
                            dt: parseFloat(retraction_dt_input.value),
                            beta_retraction: parseFloat(retraction_beta_input.value)
                        },
                        results: dutRetractionSimInstance.finalResults
                    };
                }
                else {
                    showMessage("No simulation data available to record for the current mode. Please run a simulation first.", "error", 5000);
                    return;
                }

                // Create the block content
                const prevHash = ledger.length > 0 ? ledger[ledger.length - 1].hash : '0'.repeat(64); // SHA-256 is 64 hex chars
                const blockContent = JSON.stringify({ timestamp, privacySetting, data: dataToRecord, prevHash });
                const currentHash = await sha256(blockContent); // Use real SHA-256

                const newRecord = {
                    timestamp: timestamp,
                    mode: dataToRecord.mode,
                    privacy: privacySetting,
                    hash: currentHash,
                    prev_hash: prevHash,
                    data_summary: JSON.stringify(dataToRecord.params), // Store params for quick view
                    full_data: JSON.stringify(dataToRecord) // Store full data for complete export
                };

                ledger.push(newRecord);
                localStorage.setItem(LOCAL_LEDGER_KEY, JSON.stringify(ledger));
                showMessage("Simulation data recorded to local ledger!", "info");
                updateLedgerStatus();
            } catch (error) {
                console.error("Error recording to ledger:", error);
                showMessage("Failed to record data to ledger: " + error.message, "error", 5000);
            }
        }

        /**
         * Updates the ledger status display.
         */
        function updateLedgerStatus() {
            const ledger = JSON.parse(localStorage.getItem(LOCAL_LEDGER_KEY)) || [];
            localLedgerStatus.textContent = `Ledger Status: ${ledger.length} record(s) found. Last record hash: ${ledger.length > 0 ? ledger[ledger.length - 1].hash : 'N/A'}`;
        }

        /**
         * Displays the full local ledger history.
         */
        function viewLocalLedgerHistory() {
            const ledger = JSON.parse(localStorage.getItem(LOCAL_LEDGER_KEY)) || [];
            if (ledger.length === 0) {
                ledgerHistoryContent.textContent = "No records in ledger history.";
                localLedgerHistory.classList.remove('hidden');
                return;
            }

            let historyText = "Local Ledger History:\n\n";
            ledger.forEach((record, index) => {
                historyText += `Block #${index + 1}\n`;
                historyText += `  Timestamp: ${record.timestamp}\n`;
                historyText += `  Mode: ${record.mode}\n`;
                historyText += `  Privacy: ${record.privacy}\n`;
                historyText += `  Hash: ${record.hash}\n`;
                historyText += `  Previous Hash: ${record.prev_hash}\n`;
                historyText += `  Parameters: ${record.data_summary}\n`;
                // Optionally add full_data here if needed, but it can be very long
                historyText += `------------------------------------\n`;
            });
            ledgerHistoryContent.textContent = historyText;
            localLedgerHistory.classList.remove('hidden');
        }

        /**
         * Exports the full local ledger history to a CSV file.
         */
        function exportLocalLedgerToCSV() {
            const ledger = JSON.parse(localStorage.getItem(LOCAL_LEDGER_KEY)) || [];
            if (ledger.length === 0) {
                showMessage("No ledger records to export!", "error");
                return;
            }

            // Prepare data for CSV. Flatten 'params' and 'results' from 'full_data' if desired.
            // For simplicity, let's export the core ledger record fields.
            const dataToExport = ledger.map(record => ({
                Timestamp: record.timestamp,
                Mode: record.mode,
                Privacy: record.privacy,
                Hash: record.hash,
                Previous_Hash: record.prev_hash,
                Parameters_Summary: record.data_summary,
                Full_Data_JSON: record.full_data // Export full JSON string for detailed analysis
            }));

            exportToCSV(dataToExport, 'dut_local_ledger_history.csv', [
                "Timestamp", "Mode", "Privacy", "Hash", "Previous_Hash", "Parameters_Summary", "Full_Data_JSON"
            ]);
        }

        /**
         * Clears the local ledger.
         */
        function clearLocalLedger() {
            if (confirm("Are you sure you want to clear the entire local scientific ledger? This action cannot be undone.")) {
                localStorage.removeItem(LOCAL_LEDGER_KEY);
                showMessage("Local ledger cleared successfully!", "info");
                updateLedgerStatus();
                localLedgerHistory.classList.add('hidden'); // Hide history when cleared
                ledgerHistoryContent.textContent = "";
            }
        }

        /**
         * Generates SHA-256 hash for manually entered data.
         * @returns {Promise<void>}
         */
        async function generateManualHash() {
            const data = simDataManualInput.value.trim();
            if (!data) {
                showMessage("Please paste some data into the text area to generate a hash.", "warning");
                hashOutput.textContent = "";
                return;
            }
            try {
                const hexHash = await sha256(data);
                hashOutput.textContent = `SHA-256: ${hexHash}`;
                showMessage("SHA-256 hash generated!", "info");
            } catch (error) {
                showMessage("Error generating hash. Check console for details.", "error");
                console.error("Hash generation error:", error);
            }
        }

        // ==========================================
        // Module: Internal Scientific Consistency Check (NEW)
        // ==========================================
        /**
         * Performs a consistency check between Cosmic Fossil Record and Galactic Evolution simulations.
         */
        function scientificConsistencyCheck() {
            if (!dutFossilSimInstance || !dutFossilSimInstance.finalResults || !galacticEvolutionSimInstance || !galacticEvolutionSimInstance.finalResults) {
                showMessage("Please run both 'Cosmic Fossil Record' and 'Galactic Evolution' simulations first.", "warning", 5000);
                return;
            }

            const energyExtinctionTime = dutFossilSimInstance.finalResults.extinction_time;
            const galacticTotalSimulationTime = galacticEvolutionSimInstance.finalResults.total_simulation_time;

            let message = "";
            let type = "info";

            // Threshold for "near enough" equivalence, e.g., 5% difference
            const tolerance = 0.05; // 5%
            const absoluteDifference = Math.abs(energyExtinctionTime - galacticTotalSimulationTime);
            // Avoid division by zero if both times are zero (unlikely but safe)
            const maxTime = Math.max(energyExtinctionTime, galacticTotalSimulationTime);
            const relativeDifference = maxTime > 0 ? absoluteDifference / maxTime : 0;


            if (energyExtinctionTime < galacticTotalSimulationTime) {
                message = `Inconsistency detected: Cosmic energy extinction (approx. ${energyExtinctionTime.toFixed(2)} Gyr) occurs *before* the end of the galactic evolution simulation (approx. ${galacticTotalSimulationTime.toFixed(2)} Gyr). This suggests galaxies might persist after usable energy depletion.`;
                type = "error";
            } else if (relativeDifference <= tolerance) {
                 message = `Consistency confirmed: Cosmic energy extinction time (${energyExtinctionTime.toFixed(2)} Gyr) is broadly consistent with galactic evolution simulation time (${galacticTotalSimulationTime.toFixed(2)} Gyr) within a ${tolerance*100}% tolerance.`;
                 type = "info";
            }
            else {
                message = `Potential consistency: Cosmic energy extinction (approx. ${energyExtinctionTime.toFixed(2)} Gyr) occurs *after* the end of the galactic evolution simulation (approx. ${galacticTotalSimulationTime.toFixed(2)} Gyr). This suggests galaxies may have ceased evolution while some usable energy still remains.`;
                type = "warning"; // Not an error, but worth noting
            }
            showMessage(message, type, 8000);
        }

        /**
         * Checks the theoretical validity of DUT model in specific cosmic regimes.
         */
        function checkRegimeValidity() {
            const z_valid = validateNumericInput(z_consist_newInput, z_consist_new_error_span, "Maximum Redshift");
            const m_valid = validateNumericInput(m_consist_newInput, m_consist_new_error_span, "Minimum Observed Mass");

            if (!z_valid || !m_valid) {
                showMessage("Please correct input errors for Regime Validity Check.", "error", 4000);
                return;
            }

            const z = parseFloat(z_consist_newInput.value);
            const M = parseFloat(m_consist_newInput.value); // M in solar masses

            let score = 100; // Start with full score

            // Penalties based on provided logic
            if (z > 30) {
                score -= 30; // High redshift penalty (e.g., beyond current observational/theoretical reach)
            }
            if (M < 1e7) {
                score -= 40; // Very low mass penalty (e.g., difficult to form structures in DUT)
            }
            if (z < 3) {
                score -= 20; // Low redshift penalty (e.g., less relevance for early universe theories)
            }

            // Ensure score is within 0-100
            score = Math.max(0, Math.min(100, score));

            const phrase = score > 80 ? "✅ Model valid in this regime." : "⚠️ DUT enters speculative zone.";
            consistencyOutput.textContent = `Regime Validity Score: ${score}/100\n${phrase}`;
            showMessage("DUT Regime Validity Check complete!", "info");
        }


        // ==========================================
        // Module: AI Assistant (Simple Rule-Based) (NEW)
        // ==========================================
        /**
         * Runs a simple rule-based AI check on current potential simulation parameters and results.
         */
        function runAIAssistantCheck() {
            aiAssistantOutput.textContent = "Analyzing parameters and results...";
            let messages = [];

            // Get current parameters from sliders
            const V0 = parseFloat(amplitudeSlider.value);
            const alpha = parseFloat(decaySlider.value);
            const omega = parseFloat(frequencySlider.value);
            const beta = parseFloat(centralSlider.value);
            const R_core_factor = parseFloat(radiusSlider.value);
            const rho_0_factor = parseFloat(densitySlider.value);
            const sim_time = parseFloat(simTimeSlider.value);
            const thermo_gravity_factor = parseFloat(thermoGravityFactorSlider.value);
            const entropy_evolution_rate = parseFloat(entropyEvolutionRateSlider.value);
            const decoherenceCouplingFactor = parseFloat(decoherenceCouplingFactorSlider.value);

            // Check if potential results are available
            if (Object.keys(currentPotentialResults).length === 0) {
                messages.push("🚨 Potential simulation data not found. Please run the main simulation before using the assistant.");
                aiAssistantOutput.textContent = messages.join('\n');
                return;
            }

            const {
                T_core, M_core, Omega_k,
                gtt_at_Rcore, grr_at_Rcore,
                proper_time_dilation_at_Rcore,
                quantum_decoherence_rate_at_Rcore,
                total_stress_energy_at_Rcore
            } = currentPotentialResults;

            messages.push("✅ Analysis started.");

            // Rule 1: Extreme Metric Components
            if (Math.abs(gtt_at_Rcore) < 0.001 || Math.abs(grr_at_Rcore) > 1e10) {
                messages.push("⚠️ Extreme metric components detected! g_tt near zero or g_rr very high indicates conditions approaching a singularity or black hole. Consider adjusting beta factor or central density.");
            } else if (gtt_at_Rcore > 10) {
                 messages.push("💡 High g_tt: The time dilation factor is significantly large. This may indicate strong spacetime curvature or a high-gravity environment.");
            }

            // Rule 2: Core Temperature
            if (T_core > 1e12) { // Very high temperature (e.g., above 1 trillion K)
                messages.push(`🔥 Extremely high core temperature (${T_core.toExponential(2)} K)! This suggests an intense gravitational collapse event or exotic plasma conditions.`);
            } else if (T_core < 1e-5 && T_core > 0) { // Near absolute zero but not zero
                messages.push(`❄️ Very low core temperature (${T_core.toExponential(2)} K). Conditions might approach a cold "dead universe" or low-energy gravitational collapse.`);
            }

            // Rule 3: Spatial Curvature (Omega_k)
            if (Math.abs(Omega_k) > 0.5) { // Far from flat (0)
                messages.push(`📏 Spatial curvature (${Omega_k.toFixed(4)}) is significantly non-flat. Consider the implications for the global geometry of the DUT universe.`);
            }

            // Rule 4: Quantum Decoherence Rate
            if (quantum_decoherence_rate_at_Rcore > 1e10) { // High decoherence rate
                messages.push(`⚛️ High quantum decoherence rate (${quantum_decoherence_rate_at_Rcore.toExponential(2)} Hz) at the core. This suggests quantum effects are rapidly suppressed by local gravity.`);
            } else if (quantum_decoherence_rate_at_Rcore < 1e-5) {
                messages.push(`✨ Low quantum decoherence rate. The core might sustain coherent quantum states for longer periods. Adjust decoherence coupling factor (k_Decoh) to explore further.`);
            }


            // Rule 5: Stress-Energy Density
            if (total_stress_energy_at_Rcore < 1e-30) { // Very low density
                messages.push(`🌌 Extremely low total stress-energy density (${total_stress_energy_at_Rcore.toExponential(2)} kg/m³). The core is near a vacuum or deep decay phase.`);
            } else if (total_stress_energy_at_Rcore > 1e-20) { // High density
                messages.push(`🔬 High total stress-energy density (${total_stress_energy_at_Rcore.toExponential(2)} kg/m³). The core is in a state of dense matter/energy, exploring extreme regimes.`);
            }

            // Rule 6: Thermodynamic Gravity Factor
            if (thermo_gravity_factor > 0.5) {
                messages.push("⚖️ High thermodynamic gravity factor. Entropy plays a dominant role in metric deformation.");
            } else if (thermo_gravity_factor < 0.01) {
                messages.push("⚖️ Low thermodynamic gravity factor. Entropic influence on the metric is less pronounced.");
            }

            // Rule 7: Entropy Evolution Rate
            if (entropy_evolution_rate > 0.05) {
                messages.push("💨 High entropy evolution rate. Entropic stratification over time is highly dynamic.");
            } else if (entropy_evolution_rate < 0.005) {
                messages.push("🐌 Low entropy evolution rate. Entropy distribution over time is more stable.");
            }

            // General advice/encouragement
            if (messages.length === 1 && messages[0] === "✅ Analysis started.") {
                messages.push("👍 Current parameters and results seem conceptually consistent. Keep exploring!");
            } else {
                messages.push("\nConsider adjusting parameters to explore different physical regimes of the Dead Universe Theory.");
            }

            aiAssistantOutput.textContent = messages.join('\n');
        }

        // ==========================================
        // Module: Auto-Refutation & Robustness Panel (NEW)
        // ==========================================
        /**
         * Calculates the theoretical robustness score based on predicted, confirmed, and falsified events.
         * @param {number} predicted - Number of predicted events.
         * @param {number} confirmed - Number of confirmed events.
         * @param {number} number} falsified - Number of falsified events.
         * @returns {number} Robustness score between 0 and 100.
         */
        function calculateRobustnessScore(predicted, confirmed, falsified) {
            const weightPred = 1.5; // Weight for predictions
            const weightConf = 2.0; // Weight for confirmations (more impactful)
            const weightFals = -3.0; // Weight for falsifications (highly negative impact)

            let score = (predicted * weightPred + confirmed * weightConf + falsified * weightFals);

            // Normalize score to 0-100 range, ensuring it doesn't go below 0 or above 100
            score = Math.max(0, score); // Score cannot be negative
            // Cap score at 100, assuming a theoretical maximum robustness
            score = Math.min(100, score);

            return Math.round(score); // Return as a whole number
        }

        /**
         * Generates an epistemic statement based on the robustness score.
         * @param {number} score - The calculated robustness score.
         * @returns {string} A descriptive statement about the theory's status.
         */
        function getEpistemicStatement(score) {
            if (score >= 90) return "Theory is in strong empirical alignment.";
            if (score >= 70) return "Theory within empirical integrity domain.";
            if (score >= 40) return "Borderline zone – monitor future confirmations.";
            return "Warning: theory approaching speculative threshold.";
        }

        /**
         * Runs the refutation analysis, calculates score, and updates UI.
         */
        async function runRefutationAnalysis() {
            // Validate inputs
            const pValid = validateNumericInput(predictedEventsInput, predictedEventsErrorSpan, "Predicted Events", true);
            const cValid = validateNumericInput(confirmedEventsInput, confirmedEventsErrorSpan, "Confirmed Events", true);
            const fValid = validateNumericInput(falsifiedEventsInput, falsifiedEventsErrorSpan, "Falsified Events", true);

            if (!pValid || !cValid || !fValid) {
                showMessage("Please correct the input errors for Refutation Analysis.", "error", 4000);
                return;
            }

            const p = parseInt(predictedEventsInput.value || 0);
            const c = parseInt(confirmedEventsInput.value || 0);
            const f = parseInt(falsifiedEventsInput.value || 0);

            if (p < 0 || c < 0 || f < 0) { // Extra check for non-negative
                 showMessage("Input values for events cannot be negative.", "error");
                 return;
            }

            const score = calculateRobustnessScore(p, c, f);
            const message = getEpistemicStatement(score);

            refutationResultDiv.textContent = `Score: ${score}/100 – ${message}`;
            showMessage("Refutation analysis complete!", "info");

            const dataToHash = { predicted: p, confirmed: c, falsified: f, score, message };
            await generateRefutationHash(dataToHash); // Use new function name
        }

        /**
         * Generates SHA-256 hash for the refutation data and displays it.
         * Stores data in window.currentRefutationData for export.
         * @param {Object} dataObj - The data object to hash.
         */
        async function generateRefutationHash(dataObj) {
            const dataStr = JSON.stringify(dataObj);
            const textEncoder = new TextEncoder();
            const data = textEncoder.encode(dataStr);
            const hashBuffer = await crypto.subtle.digest('SHA-256', data);
            const hashArray = Array.from(new Uint8Array(hashBuffer));
            const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
            refutationHashDiv.textContent = "SHA-256: " + hashHex;
            window.currentRefutationData = { ...dataObj, hash: hashHex };
        }

        /**
         * Exports the current refutation data to a JSON file.
         */
        function exportRefutationJSON() {
            if (!window.currentRefutationData) {
                showMessage("Please run the 'Calculate Score' first to generate data for export.", "error");
                return;
            }
            const blob = new Blob([JSON.stringify(window.currentRefutationData, null, 2)], { type: "application/json" });
            const link = document.createElement("a");
            link.href = URL.createObjectURL(blob);
            link.download = "dut_refutation_analysis.json"; // More specific filename
            link.click();
            showMessage("Refutation data exported to JSON!", "info");
        }

        /**
         * Exports the current refutation data to a TXT file.
         */
        function exportRefutationTXT() {
            if (!window.currentRefutationData) {
                showMessage("Please run the 'Calculate Score' first to generate data for export.", "error");
                return;
            }
            const { predicted, confirmed, falsified, score, message, hash } = window.currentRefutationData;
            const content = `DUT Epistemic Robustness Report
-----------------------------
Predicted Events: ${predicted}
Confirmed Events: ${confirmed}
Falsified Events: ${falsified}

Robustness Score: ${score}/100
Epistemic Verdict: ${message}

SHA-256 Hash: ${hash}`;
            const blob = new Blob([content], { type: "text/plain" });
            const link = document.createElement("a");
            link.href = URL.createObjectURL(blob);
            link.download = "dut_refutation_report.txt"; // More specific filename
            link.click();
            showMessage("Refutation report exported to TXT!", "info");
        }

        // ==========================================
        // Module: DUT Interactive Console (NEW)
        // ==========================================

        const consoleKnowledgeBase = {
            "help": "Available commands:\n- 'show constants': display physical constants.\n- 'explain [term]': get info on 'potential', 'entropy', 'decoherence', 'ledger', 'refutation', 'ai', 'data', 'srd', 'galaxybirthdeath', 'hawking', 'curvature', 'darkbiology', 'mirror', 'fossiltime', 'regimevalidity', 'manualhash', 'fossiladv'.\n- 'set [param] [value]': e.g., 'set amplitude 1.2', 'set fossil_tmax 250', 'set betaSRD 3.0', 'set D_mirror 0.5', 'set z_fossil 10', 'set mass_fossil_adv 2.0', 'set type_fossil_adv spiral', 'set n0_galaxy_dating 1500'.\n- 'run [module]': e.g., 'run potential', 'run fossil', 'run galactic', 'run retraction', 'run srd', 'run galaxybirthdeath', 'run hawking', 'run curvature', 'run darkbiology', 'run mirror', 'run fossiltime', 'run regimevalidity', 'run manualhash', 'run fossiladv'.\n- 'load [data_source] data': e.g., 'load JWST data', 'load NASA data'.\n- 'import file': open file dialog to import local CSV/JSON data.\n- 'analyze refutation [predicted] [confirmed] [falsified]': e.g., 'analyze refutation 10 5 1'.",
            "constants": `Physical Constants:
- HBAR (Reduced Planck): ${HBAR.toExponential(4)} J·s
- C (Speed of Light): ${C.toExponential(4)} m/s
- KB (Boltzmann Constant): ${KB.toExponential(4)} J/K
- G (Gravitational Constant): ${G.toExponential(4)} N·m²/kg²
- SOLAR_MASS: ${SOLAR_MASS.toExponential(4)} kg
- PLANCK_LENGTH: ${PLANCK_LENGTH.toExponential(4)} m
- PLANCK_MASS: ${PLANCK_MASS.toExponential(4)} kg
- PROTON_MASS: ${PROTON_MASS.toExponential(4)} kg
- HUBBLE_CONSTANT (main): ${H0_KM_S_MPC} km/s/Mpc
- HUBBLE_CONSTANT (patch): ${H0_PATCH_KM_S_MPC} km/s/Mpc
- SPEED_OF_LIGHT_KM_S: ${C_KM_S} km/s
- LIGHT_YEAR_TO_METERS: ${LIGHT_YEAR_TO_METERS.toExponential(4)} m
- SECONDS_PER_GYR: ${SECONDS_PER_GYR.toExponential(4)} s`,
            "potential": "The 'Gravitational Potential' module visualizes the cosmic core potential, incorporating oscillatory, central, and quantum corrections. Parameters control amplitude, frequency, decay, core size, and density.",
            "entropy": "The 'Dynamic Entropic Gradient and Information Gravity' concept suggests entropy gradients influence spacetime, contributing to the metric tensor (∇S ~ -dV/dr · ρ).",
            "decoherence": "The 'Quantum Decoherence Rate' models the loss of quantum coherence near the core due to gravitational interactions and thermal dissipation, influenced by local density, temperature, and a coupling factor.",
            "ledger": "The 'Local Scientific Ledger' is a proof-of-concept for immutable data record-keeping using browser local storage and SHA-256 hashing, similar to a blockchain, but purely client-side.",
            "refutation": "The 'Self-Refutation & Robustness Panel' allows you to conceptually assess the theoretical strength of DUT based on the number of predicted, confirmed, and falsified events.",
            "ai": "The 'DUT Consistency Assistant' is a simple rule-based AI that checks for conceptual inconsistencies in your simulation parameters and results, offering suggestions.",
            "data": "The 'Observational Data' panel provides simulated data (JWST, NASA Earth) and allows you to import your own data files (CSV/JSON) that you have downloaded manually from external sources (e.g., NASA, ESA, JAXA, Roscosmos portals).",
            "srd": "The 'SRD Abundance' module simulates the conceptual abundance of Spontaneously Recombining Dark (SRD) particles at high redshift, reflecting a theoretical early universe phase.",
            "galaxybirthdeath": "The 'Galaxy Birth–Death Dating Model' models the evolution of active galaxy populations over cosmic time, considering initial formation and a decay process, for conceptual cosmic dating.",
            "hawking": "The 'Hawking Radiation Evaporation Time' module calculates the theoretical evaporation time of black holes due to Hawking radiation, a quantum gravitational effect.",
            "curvature": "The 'Spacetime Curvature Model' is a conceptual model illustrating different global spacetime curvatures (positive, negative, asymmetric) within the DUT framework.",
            "darkbiology": "The 'Dark Biology Simulation' module explores the conceptual 'bio-potential' in extreme cosmic environments based on entropy gradients, a speculative aspect of DUT.",
            "mirror": "The 'DUT Quantum Mirror Experiment' simulates the theoretical delay in light reflection from a distant quantum mirror, incorporating classical travel time, entropy-induced deformation, and local gravitational perturbations.",
            "fossiltime": "The 'Cosmic Time at Redshift' calculation estimates the age of the universe at a given redshift (z) using a simplified cosmological model, providing a cosmic dating tool within the Fossil Record module.",
            "regimevalidity": "The 'DUT Regime Validity Score' evaluates the theoretical validity of the DUT model in specific cosmic regimes based on maximum redshift and minimum observed mass, providing a 'consistency score' for theoretical robustness." ,
            "manualhash": "The 'Manual SHA-256 Hashing' allows you to paste any data and generate its SHA-256 hash, useful for verifying data integrity or creating custom ledger entries.",
            "fossiladv": "The 'Cosmic Fossil Record Simulator (Advanced)' simulates 'fossil density' based on redshift, galaxy mass, and type, with an option to include JWST model data. It provides a visual plot and CSV export."
        };

        function appendToConsole(message) {
            const now = new Date();
            const timeString = now.toLocaleTimeString('en-US', { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit' });
            consoleOutput.textContent += `[${timeString}] ${message}\n`;
            consoleOutput.scrollTop = consoleOutput.scrollHeight; // Scroll to bottom
        }

        async function processConsoleCommand(command) {
            command = command.trim().toLowerCase();
            appendToConsole(`> ${command}`); // Echo command

            if (command === 'help') {
                appendToConsole(consoleKnowledgeBase.help);
            } else if (command === 'show constants') {
                appendToConsole(consoleKnowledgeBase.constants);
            } else if (command.startsWith('explain ')) {
                const term = command.substring(8).trim();
                if (consoleKnowledgeBase[term]) {
                    appendToConsole(consoleKnowledgeBase[term]);
                } else {
                    appendToConsole(`Error: No explanation found for '${term}'. Try 'explain potential', 'explain entropy', 'explain data', etc.`);
                }
            } else if (command.startsWith('set ')) {
                const parts = command.split(' ');
                if (parts.length === 3) {
                    const paramName = parts[1];
                    const paramValue = parseFloat(parts[2]);
                    let targetElement = null;
                    let targetSpan = null;

                    const paramMap = {
                        "amplitude": { el: amplitudeSlider, span: amplitudeValueSpan, fixed: 1 },
                        "frequency": { el: frequencySlider, span: frequencyValueSpan, fixed: 1 },
                        "decay": { el: decaySlider, span: decayValueSpan, fixed: 2 },
                        "central": { el: centralSlider, span: centralValueSpan, fixed: 1 },
                        "radius": { el: radiusSlider, span: radiusValueSpan, fixed: 1 },
                        "density": { el: densitySlider, span: densityValueSpan, fixed: 1 },
                        "simtime": { el: simTimeSlider, span: simTimeValSpan, fixed: 1 },
                        "thermogravityfactor": { el: thermoGravityFactorSlider, span: thermoGravityFactorValSpan, fixed: 2 },
                        "entropyevolutionrate": { el: entropyEvolutionRateSlider, span: entropyEvolutionRateValSpan, fixed: 3 },
                        "decoherencecouplingfactor": { el: decoherenceCouplingFactorSlider, span: decoherenceCouplingFactorValSpan, fixed: 1 },
                        "fossil_t0": { el: fossil_t0_input, span: fossil_t0_val_span, inputType: 'number' },
                        "fossil_tmax": { el: fossil_tmax_input, span: fossil_tmax_val_span, inputType: 'number' },
                        "fossil_dt": { el: fossil_dt_input, span: fossil_dt_val_span, inputType: 'number' },
                        "fossil_beta": { el: fossil_beta_input, span: fossil_beta_val_span, inputType: 'number' },
                        "galactic_alpha": { el: galactic_alpha_input, span: galactic_alpha_val_span, inputType: 'number' },
                        "galactic_n0": { el: galactic_N0_input, span: galactic_N0_val_span, inputType: 'number', format: (val) => parseFloat(val).toLocaleString() },
                        "galactic_nf_dot": { el: galactic_Nf_dot_input, span: galactic_Nf_dot_val_span, inputType: 'number', format: (val) => parseFloat(val).toLocaleString() },
                        "galactic_total_time": { el: galactic_total_time_input, span: galactic_total_time_val_span, inputType: 'number' },
                        "galactic_dt": { el: galactic_dt_input, span: galactic_dt_val_span, inputType: 'number' },
                        "retraction_tmax": { el: retraction_tmax_input, span: retraction_tmax_val_span, inputType: 'number' },
                        "retraction_dt": { el: retraction_dt_input, span: retraction_dt_val_span, inputType: 'number' },
                        "retraction_beta": { el: retraction_beta_input, span: retraction_beta_val_span, inputType: 'number' },
                        "predictedevents": { el: predictedEventsInput, inputType: 'number' },
                        "confirmedevents": { el: confirmedEventsInput, inputType: 'number' },
                        "falsifiedevents": { el: falsifiedEventsInput, inputType: 'number' },
                        // Advanced Modules Parameters
                        "betasrd": { el: betaSRDInput, inputType: 'number' },
                        "gammasrd": { el: gammaSRDInput, inputType: 'number' },
                        "n0_galaxy_dating": { el: N0_galaxy_dating_input, inputType: 'number' },
                        "beta_galaxy_dating": { el: beta_galaxy_dating_input, inputType: 'number' },
                        "duration_galaxy_dating": { el: duration_galaxy_dating_input, inputType: 'number' },
                        "bhmass": { el: bhMassSelect, inputType: 'select' },
                        "entropygrad": { el: entropyGradInput, inputType: 'number' },
                        "lambdabio": { el: lambdaBioInput, inputType: 'number' },
                        // Quantum Mirror Module Parameters
                        "d_mirror": { el: D_mirrorInput, inputType: 'number' },
                        "grads_mirror": { el: gradS_mirrorInput, inputType: 'number' },
                        "deltag_mirror": { el: deltaG_mirrorInput, inputType: 'number' },
                        "eta_mirror": { el: eta_mirrorInput, inputType: 'number' },
                        // Patch Modules Parameters
                        "z_fossil": { el: z_fossil_newInput, inputType: 'number' }, // For new fossil time calc
                        "z_consist": { el: z_consist_newInput, inputType: 'number' }, // For regime validity
                        "m_consist": { el: m_consist_newInput, inputType: 'number' }, // For regime validity
                        // Advanced Fossil Module Parameters
                        "mass_fossil_adv": { el: mass_fossil_adv_input, inputType: 'number' },
                        "type_fossil_adv": { el: type_fossil_adv_select, inputType: 'select' }
                    };

                    const mappedParam = paramMap[paramName];
                    if (mappedParam) {
                        targetElement = mappedParam.el;
                        targetSpan = mappedParam.span;

                        if (targetElement) {
                            if (mappedParam.inputType === 'select') {
                                const optionExists = Array.from(targetElement.options).some(option => option.value === String(paramValue) || parseFloat(option.value) === paramValue);
                                if (optionExists) {
                                    targetElement.value = String(paramValue); // Ensure value is set as string for select
                                    appendToConsole(`Set ${paramName} to ${paramValue}.`);
                                } else {
                                    appendToConsole(`Error: Value ${paramValue} is not a valid option for ${paramName}.`);
                                }
                            } else if (!isNaN(paramValue)) {
                                const minVal = parseFloat(targetElement.min);
                                const maxVal = parseFloat(targetElement.max);

                                if (paramValue >= minVal && (isNaN(maxVal) || paramValue <= maxVal)) {
                                    targetElement.value = paramValue;
                                    if (targetSpan) {
                                        if (mappedParam.format) {
                                            targetSpan.textContent = mappedParam.format(paramValue);
                                        } else {
                                            targetSpan.textContent = mappedParam.fixed ? paramValue.toFixed(mappedParam.fixed) : paramValue;
                                        }
                                    }
                                    appendToConsole(`Set ${paramName} to ${paramValue}.`);
                                    // Trigger updates for associated modules
                                    if (paramName === 'z_fossil') computeFossilTime();
                                    if (paramName === 'z_consist' || paramName === 'm_consist') checkRegimeValidity();
                                    if (paramName === 'mass_fossil_adv' || paramName === 'type_fossil_adv') simulateFossilsAdvanced();
                                    if (paramName === 'n0_galaxy_dating' || paramName === 'beta_galaxy_dating' || paramName === 'duration_galaxy_dating') simulateGalaxyBirthDeathDating(); // Call the new dating function
                                    if (currentSimulationMode === 'potential') {
                                        drawGravitationalMetricsAndEntropicFields();
                                    }
                                } else {
                                    appendToConsole(`Error: Value ${paramValue} is out of range for ${paramName} (min: ${targetElement.min}, max: ${targetElement.max || 'N/A'}).`);
                                }
                            } else {
                                appendToConsole(`Error: Value for '${paramName}' is invalid.`);
                            }
                        } else {
                            appendToConsole(`Error: Could not find parameter '${paramName}'.`);
                        }
                    } else {
                        appendToConsole(`Error: Unknown parameter '${paramName}'.`);
                    }
                } else {
                    appendToConsole("Usage: 'set [parameter_name] [value]'");
                }
            } else if (command.startsWith('run ')) {
                const moduleName = command.substring(4).trim();
                let success = false;
                if (moduleName === 'potential') {
                    allModeButtons[0].click();
                    drawGravitationalMetricsAndEntropicFields();
                    success = true;
                } else if (moduleName === 'fossil') {
                    allModeButtons[1].click();
                    runFossilSimBtn.click();
                    success = true;
                } else if (moduleName === 'galactic') {
                    allModeButtons[2].click();
                    runGalacticSimBtn.click();
                    success = true;
                } else if (moduleName === 'retraction') {
                    allModeButtons[3].click();
                    runRetractionSimBtn.click();
                    success = true;
                }
                // Advanced Modules Run Commands
                else if (moduleName === 'srd') {
                    plotSRDBtn.click();
                    success = true;
                } else if (moduleName === 'galaxybirthdeath') {
                    simulateGalaxyBirthDeathBtn_dating.click(); // Call the new dating function's button
                    success = true;
                } else if (moduleName === 'hawking') {
                    calcEvaporationBtn.click();
                    success = true;
                } else if (moduleName === 'curvature') {
                    displayCurvatureBtn.click();
                    success = true;
                } else if (moduleName === 'darkbiology') {
                    simulateBiologyBtn.click();
                    success = true;
                } else if (moduleName === 'mirror') {
                    simulateMirrorBtn.click();
                    success = true;
                }
                // Patch Modules Run Commands
                else if (moduleName === 'fossiltime') {
                    computeFossilTime();
                    success = true;
                } else if (moduleName === 'regimevalidity') {
                    checkRegimeValidity();
                    success = true;
                } else if (moduleName === 'manualhash') {
                    generateManualHash();
                    success = true;
                } else if (moduleName === 'fossiladv') {
                    simulateFossilsAdvancedBtn.click(); // Call the new advanced fossil button
                    success = true;
                }
                else {
                    appendToConsole(`Error: Unknown simulation module '${moduleName}'. Try 'potential', 'fossil', 'galactic', 'retraction', 'srd', 'galaxybirthdeath', 'hawking', 'curvature', 'darkbiology', 'mirror', 'fossiltime', 'regimevalidity', 'manualhash', 'fossiladv'.`);
                }
                if (success) appendToConsole(`Running ${moduleName} simulation.`);
            } else if (command.startsWith('load ')) {
                const dataSource = command.substring(5).trim();
                if (dataSource === 'jwst data') {
                    loadJWSTDataBtn.click();
                    appendToConsole("Loading simulated JWST galaxy data to Observational Data panel.");
                } else if (dataSource === 'nasa data') {
                    loadNASAEarthDataBtn.click();
                    appendToConsole("Loading simulated NASA Earth data to Observational Data panel.");
                } else {
                    appendToConsole(`Error: Unknown data source '${dataSource}'. Try 'JWST data' or 'NASA data'.`);
                }
            } else if (command === 'import file') {
                localFileInput.click();
                appendToConsole("Please select a local data file (CSV or JSON).");
            } else if (command.startsWith('analyze refutation ')) {
                const parts = command.substring(19).split(' ').map(Number);
                if (parts.length === 3 && parts.every(val => !isNaN(val) && val >= 0)) {
                    predictedEventsInput.value = parts[0];
                    confirmedEventsInput.value = parts[1];
                    falsifiedEventsInput.value = parts[2];
                    runRefutationAnalysis();
                    appendToConsole(`Analyzing refutation with Predicted: ${parts[0]}, Confirmed: ${parts[1]}, Falsified: ${parts[2]}.`);
                } else {
                    appendToConsole("Error: Invalid numbers for refutation analysis. Usage: 'analyze refutation [predicted] [confirmed] [falsified]'");
                }
            } else {
                appendToConsole("Error: Unknown command. Type 'help' for a list of commands.");
            }
        }

        /**
         * Parses CSV string into an array of objects.
         * Assumes first row is header.
         * @param {string} csvString
         * @returns {Array<Object>}
         */
        function parseCSV(csvString) {
            const lines = csvString.trim().split('\n');
            if (lines.length === 0) return [];

            const headers = lines[0].split(',').map(h => h.trim());
            const result = [];

            for (let i = 1; i < lines.length; i++) {
                const values = lines[i].split(',').map(v => v.trim());
                if (values.length !== headers.length) continue; // Skip malformed rows

                const rowObject = {};
                for (let j = 0; j < headers.length; j++) {
                    // Attempt to convert to number if possible, otherwise keep as string
                    const numVal = parseFloat(values[j]);
                    rowObject[headers[j]] = isNaN(numVal) ? values[j] : numVal;
                }
                result.push(rowObject);
            }
            return result;
        }

        /**
         * Displays imported data from a file in the observational data display.
         * @param {string} filename - Name of the imported file.
         * @param {Object[]|Object} data - Parsed data (array of objects for CSV, object for JSON).
         */
        function displayImportedData(filename, data) {
            let displayContent = `--- Data from: ${filename} ---\n\n`;
            if (Array.isArray(data)) {
                // CSV or array of JSON objects
                data.forEach((row, index) => {
                    displayContent += `Entry ${index + 1}:\n`;
                    for (const key in row) {
                        displayContent += `  ${key}: ${JSON.stringify(row[key])}\n`;
                    }
                    displayContent += `---\n`;
                });
            } else if (typeof data === 'object' && data !== null) {
                // Single JSON object
                displayContent += JSON.stringify(data, null, 2); // Pretty print JSON
            } else {
                displayContent += "Could not parse data content.";
            }
            observationalDataDisplay.textContent = displayContent;
            showMessage(`Successfully imported data from ${filename}!`, "info");
        }

        // ==========================================
        // Module: SRDs Abundance at z ≈ 20 (Advanced Module)
        // ==========================================
        function plotSRD() {
            // Validate inputs
            const betaValid = validateNumericInput(betaSRDInput, betaSRD_error_span, "SRD Beta");
            const gammaValid = validateNumericInput(gammaSRDInput, gammaSRD_error_span, "SRD Gamma");
            if (!betaValid || !gammaValid) {
                showMessage("Please correct SRD input errors.", "error", 4000);
                return;
            }

            const beta = parseFloat(betaSRDInput.value);
            const gamma = parseFloat(gammaSRDInput.value);
            srdCtx.clearRect(0, 0, srdCanvas.width, srdCanvas.height);

            // Set margins for axes and labels
            const margin = 30;
            const plotWidth = srdCanvas.width - 2 * margin;
            const plotHeight = srdCanvas.height - 2 * margin;

            // Find max Y value for dynamic scaling
            let maxY = 0;
            for (let z = 0; z <= 40; z += 0.5) {
                const A = 1.0;
                const y = A * Math.pow(1 + z, beta) * Math.exp(-gamma * Math.pow(z - 20, 2));
                if (y > maxY) maxY = y;
            }
            maxY = Math.max(maxY, 0.1); // Ensure a minimum scale if values are very small

            // Draw axes
            srdCtx.strokeStyle = varCss('--axis-color');
            srdCtx.lineWidth = 1;
            srdCtx.beginPath();
            srdCtx.moveTo(margin, srdCanvas.height - margin); // X-axis
            srdCtx.lineTo(srdCanvas.width - margin, srdCanvas.height - margin);
            srdCtx.moveTo(margin, srdCanvas.height - margin); // Y-axis
            srdCtx.lineTo(margin, margin);
            srdCtx.stroke();

            // Draw labels and ticks
            srdCtx.fillStyle = varCss('--text-color-secondary');
            srdCtx.font = '10px Arial';
            srdCtx.textAlign = 'center';
            srdCtx.fillText('Redshift (z)', srdCanvas.width / 2, srdCanvas.height - 5);
            srdCtx.save();
            srdCtx.translate(15, srdCanvas.height / 2); // Adjust position for Y-axis label
            srdCtx.rotate(-Math.PI / 2);
            srdCtx.fillText('Relative Abundance', 0, 0);
            srdCtx.restore();

            // X-axis ticks (redshift)
            for (let i = 0; i <= 4; i++) { // 0, 10, 20, 30, 40
                const zTick = i * 10;
                const x = margin + (zTick / 40) * plotWidth;
                srdCtx.fillText(zTick, x, srdCanvas.height - margin + 15);
            }

            // Y-axis ticks (abundance)
            for (let i = 0; i <= 5; i++) { // 0, 20%, 40%, 60%, 80%, 100% of maxY
                const yTickVal = (i / 5) * maxY;
                const y = srdCanvas.height - margin - (i / 5) * plotHeight;
                srdCtx.fillText(yTickVal.toFixed(1), margin - 10, y + 3); // Label slightly to the left
            }


            srdCtx.beginPath();
            srdCtx.strokeStyle = '#90cdf4'; // Light blue for SRD curve
            srdCtx.lineWidth = 2;

            const maxZ = 40; // Max redshift for plot

            for (let z = 0; z <= maxZ; z += 0.5) {
                const A = 1.0; // Amplitude
                // Conceptual model for SRD abundance peaking around z=20
                const y = A * Math.pow(1 + z, beta) * Math.exp(-gamma * Math.pow(z - 20, 2));

                const xPos = margin + (z / maxZ) * plotWidth;
                const yPos = srdCanvas.height - margin - (y / maxY) * plotHeight;

                if (z === 0) srdCtx.moveTo(xPos, yPos);
                else srdCtx.lineTo(xPos, yPos);
            }
            srdCtx.stroke();
            srdOutput.textContent = `SRD Abundance simulated with β=${beta}, γ=${gamma}. Peak likely around z=20.`;
            showMessage("SRD Abundance simulation complete!", "info");
        }

        // ==========================================
        // Module: Galaxy Birth-Death Dating Model (Advanced Module)
        // ==========================================
        function simulateGalaxyBirthDeathDating() { // Renamed function
            // Validate inputs
            const N0Valid = validateNumericInput(N0_galaxy_dating_input, N0_galaxy_dating_error_span, "Galaxy N0");
            const betaGValid = validateNumericInput(beta_galaxy_dating_input, beta_galaxy_dating_error_span, "Galaxy Decay Beta");
            const timeGValid = validateNumericInput(duration_galaxy_dating_input, duration_galaxy_dating_error_span, "Galaxy Time");
            if (!N0Valid || !betaGValid || !timeGValid) {
                showMessage("Please correct Galaxy Birth-Death input errors.", "error", 4000);
                return;
            }

            const N0 = parseFloat(N0_galaxy_dating_input.value);
            const beta = parseFloat(beta_galaxy_dating_input.value);
            const duration = parseFloat(duration_galaxy_dating_input.value);
            const rejuvenate = rejuvenate_galaxy_dating_checkbox.checked;

            galaxyBirthDeathCtx.clearRect(0, 0, galaxyBirthDeathCanvas.width, galaxyBirthDeathCanvas.height);
            galaxyBirthDeathCtx.beginPath();
            galaxyBirthDeathCtx.strokeStyle = "#90cdf4";

            const log = [];

            const maxN = N0 * (rejuvenate ? 1.25 : 1); // Max N for scaling the plot, considering rejuvenation peak
            const margin = 30;
            const plotWidth = galaxyBirthDeathCanvas.width - 2 * margin;
            const plotHeight = galaxyBirthDeathCanvas.height - 2 * margin;

            // Draw axes
            galaxyBirthDeathCtx.strokeStyle = varCss('--axis-color');
            galaxyBirthDeathCtx.lineWidth = 1;
            galaxyBirthDeathCtx.beginPath();
            galaxyBirthDeathCtx.moveTo(margin, galaxyBirthDeathCanvas.height - margin); // X-axis
            galaxyBirthDeathCtx.lineTo(galaxyBirthDeathCanvas.width - margin, galaxyBirthDeathCanvas.height - margin);
            galaxyBirthDeathCtx.moveTo(margin, galaxyBirthDeathCanvas.height - margin); // Y-axis
            galaxyBirthDeathCtx.lineTo(margin, margin);
            galaxyBirthDeathCtx.stroke();

            // Draw labels
            galaxyBirthDeathCtx.fillStyle = varCss('--text-color-secondary');
            galaxyBirthDeathCtx.font = '10px Arial';
            galaxyBirthDeathCtx.textAlign = 'center';
            galaxyBirthDeathCtx.fillText('Time (Gyr)', galaxyBirthDeathCanvas.width / 2, galaxyBirthDeathCanvas.height - 5);
            galaxyBirthDeathCtx.save();
            galaxyBirthDeathCtx.translate(15, galaxyBirthDeathCanvas.height / 2);
            galaxyBirthDeathCtx.rotate(-Math.PI / 2);
            galaxyBirthDeathCtx.fillText('Active Galaxies (N)', 0, 0);
            galaxyBirthDeathCtx.restore();

            // X-axis ticks (time)
            for (let i = 0; i <= 4; i++) { // 0, 1/4, 1/2, 3/4, 1 of duration
                const tTick = (i / 4) * duration;
                const x = margin + (tTick / duration) * plotWidth;
                galaxyBirthDeathCtx.fillText(tTick.toFixed(0), x, galaxyBirthDeathCanvas.height - margin + 15);
            }

            // Y-axis ticks (galaxy count)
            for (let i = 0; i <= 5; i++) { // 0, 20%, ..., 100% of maxN
                const nTickVal = (i / 5) * maxN;
                const y = galaxyBirthDeathCanvas.height - margin - (i / 5) * plotHeight;
                galaxyBirthDeathCtx.fillText(nTickVal.toExponential(0), margin - 10, y + 3);
            }


            for (let t = 0; t <= duration; t++) {
                let noise = 1 + (Math.random() - 0.5) * 0.1; // 10% variability
                let N = N0 * Math.exp(-beta * t) * noise;

                if (rejuvenate && t > 120 && t < 140) {
                    N *= 1.25; // simulate starburst at Reionization peak
                }

                const x = margin + (t / duration) * plotWidth;
                const y = galaxyBirthDeathCanvas.height - margin - (N / maxN) * plotHeight; // Scale N for plot

                if (t === 0) galaxyBirthDeathCtx.moveTo(x, y);
                else galaxyBirthDeathCtx.lineTo(x, y);
                log.push(`t=${t} Gyr → N(t) ≈ ${N.toFixed(2)}`);
            }

            galaxyBirthDeathCtx.stroke();
            galaxyBirthDeathLog.textContent = log.join("\n");
            showMessage("Galaxy Birth-Death simulation complete!", "info");
        }

        // ==========================================
        // Module: Cosmic Fossil Record Simulator (Advanced)
        // ==========================================
        const sampleDataJWST = [
            { z: 5, value: 0.8 }, { z: 10, value: 1.2 }, { z: 15, value: 2.8 },
            { z: 18, value: 4.0 }, { z: 20, value: 4.8 }, { z: 23, value: 3.6 },
            { z: 28, value: 2.1 }, { z: 32, value: 1.1 }
        ];

        function simulateFossilsAdvanced() { // Renamed function
            // Validate inputs
            const massValid = validateNumericInput(mass_fossil_adv_input, mass_fossil_adv_error_span, "Galaxy Mass");
            if (!massValid) {
                showMessage("Please correct Advanced Fossil Record input errors.", "error", 4000);
                return;
            }

            const mass = parseFloat(mass_fossil_adv_input.value);
            const type = type_fossil_adv_select.value;
            const includeData = includeData_fossil_adv_checkbox.checked;

            fossilCtxAdvanced.clearRect(0, 0, fossilCanvasAdvanced.width, fossilCanvasAdvanced.height);

            // Set margins for axes and labels
            const margin = 30;
            const plotWidth = fossilCanvasAdvanced.width - 2 * margin;
            const plotHeight = fossilCanvasAdvanced.height - 2 * margin;

            // Simple mass/type multiplier
            const base = { elliptical: 1.0, lenticular: 0.8, spiral: 0.6 }[type];
            const A = 1.0 * mass * base;
            const beta = 2.0;
            const gamma = 0.25;
            const zc = 20;
            fossilPointsAdvanced = [];

            // Determine max Y value for dynamic scaling
            let maxY = 0;
            const maxZ = 35; // Max redshift for plot
            for (let z = 0; z <= maxZ; z += 0.5) {
                const val = A * Math.pow(1 + z, beta) * Math.exp(-gamma * Math.pow(z - zc, 2));
                if (val > maxY) maxY = val;
            }
            if (includeData) { // Also consider JWST data for max Y
                sampleDataJWST.forEach(pt => {
                    if (pt.value * 25 > maxY) maxY = pt.value * 25; // Scale factor 25 from original snippet
                });
            }
            maxY = Math.max(maxY, 1); // Ensure a minimum scale

            // Draw axes
            fossilCtxAdvanced.strokeStyle = varCss('--axis-color');
            fossilCtxAdvanced.lineWidth = 1;
            fossilCtxAdvanced.beginPath();
            fossilCtxAdvanced.moveTo(margin, fossilCanvasAdvanced.height - margin); // X-axis
            fossilCtxAdvanced.lineTo(fossilCanvasAdvanced.width - margin, fossilCanvasAdvanced.height - margin);
            fossilCtxAdvanced.moveTo(margin, fossilCanvasAdvanced.height - margin); // Y-axis
            fossilCtxAdvanced.lineTo(margin, margin);
            fossilCtxAdvanced.stroke();

            // Draw labels and ticks
            fossilCtxAdvanced.fillStyle = varCss('--text-color-secondary');
            fossilCtxAdvanced.font = '10px Arial';
            fossilCtxAdvanced.textAlign = 'center';
            fossilCtxAdvanced.fillText('Redshift (z)', fossilCanvasAdvanced.width / 2, fossilCanvasAdvanced.height - 5);
            fossilCtxAdvanced.save();
            fossilCtxAdvanced.translate(15, fossilCanvasAdvanced.height / 2);
            fossilCtxAdvanced.rotate(-Math.PI / 2);
            fossilCtxAdvanced.fillText('Fossil Density', 0, 0);
            fossilCtxAdvanced.restore();

            // X-axis ticks (redshift)
            for (let i = 0; i <= 7; i++) { // 0, 5, 10, ..., 35
                const zTick = i * 5;
                const x = margin + (zTick / maxZ) * plotWidth;
                fossilCtxAdvanced.fillText(zTick, x, fossilCanvasAdvanced.height - margin + 15);
            }

            // Y-axis ticks (density)
            for (let i = 0; i <= 5; i++) { // 0, 20%, ..., 100% of maxY
                const yTickVal = (i / 5) * maxY;
                const y = fossilCanvasAdvanced.height - margin - (i / 5) * plotHeight;
                fossilCtxAdvanced.fillText(yTickVal.toFixed(1), margin - 10, y + 3);
            }


            fossilCtxAdvanced.beginPath();
            fossilCtxAdvanced.strokeStyle = '#90cdf4';
            fossilCtxAdvanced.lineWidth = 2;

            for (let z = 0; z <= maxZ; z += 0.5) {
                const val = A * Math.pow(1 + z, beta) * Math.exp(-gamma * Math.pow(z - zc, 2));
                fossilPointsAdvanced.push({ z: z.toFixed(1), density: val });
                const x = margin + (z / maxZ) * plotWidth;
                const y = fossilCanvasAdvanced.height - margin - (val / maxY) * plotHeight; // Scale for plot
                if (z === 0) fossilCtxAdvanced.moveTo(x, y);
                else fossilCtxAdvanced.lineTo(x, y);
            }
            fossilCtxAdvanced.stroke();

            if (includeData) {
                fossilCtxAdvanced.fillStyle = '#f56565';
                sampleDataJWST.forEach(pt => {
                    const x = margin + (pt.z / maxZ) * plotWidth;
                    const y = fossilCanvasAdvanced.height - margin - (pt.value * 25 / maxY) * plotHeight; // Scale for plot
                    fossilCtxAdvanced.beginPath();
                    fossilCtxAdvanced.arc(x, y, 4, 0, 2 * Math.PI);
                    fossilCtxAdvanced.fill();
                });
            }
            showMessage("Advanced Cosmic Fossil Record simulation complete!", "info");
        }

        function exportFossilDataAdvanced() { // Renamed function
            if (fossilPointsAdvanced.length === 0) {
                showMessage("No advanced fossil data to export! Run the simulation first.", "error");
                return;
            }
            let csv = "z,density\n";
            fossilPointsAdvanced.forEach(pt => {
                csv += `${pt.z},${pt.density.toFixed(3)}\n`;
            });
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = 'fossil_record_advanced.csv';
            link.click();
            showMessage("Advanced Fossil Record data exported to CSV!", "info");
        }


        // ==========================================
        // Module: Hawking Radiation Evaporation Time (Advanced Module)
        // ==========================================
        function calcEvaporation() {
            const M_solar_masses = parseFloat(bhMassSelect.value);
            // Evaporation time formula: T_evap ≈ 8π G² M³ / (ħ c⁴)
            // Using precise constants and converting M_solar_masses to kg first
            const M_kg = M_solar_masses * SOLAR_MASS;

            // Simplified formula for evaporation time in seconds (T_evap ~ M^3)
            // The constant for M in kg, time in seconds is approx. 8.4 x 10^-17 (s/kg^3)
            // More accurately, using Stephen Hawking's formula:
            // T_evap = (5120 * PI * G^2 * M_kg^3) / (hbar * c^4)
            // This yields a very large number, so often a simplified constant is used.
            // Using the value from the original snippet (2.1e67 years for 1 solar mass BH) and converting:
            // 2.1e67 years * (365.25 days/year * 24 hours/day * 3600 seconds/hour) = ~6.62e74 seconds for 1 M☉
            // So, for M in solar masses, time in seconds = ~6.62e74 * M_solar_masses^3 seconds.
            const T_evap_seconds = 6.62e74 * Math.pow(M_solar_masses, 3);
            const T_evap_trillion_years = T_evap_seconds / (SECONDS_PER_GYR * 1e3); // Convert seconds to trillion years (SECONDS_PER_GYR seconds/Gyr * 1e3 Gyr/trillion_years)

            hawkingOutput.textContent = `Evaporation time for M = ${M_solar_masses.toExponential(0)} M☉ is ≈ ${T_evap_trillion_years.toExponential(2)} trillion years.`;
            showMessage("Hawking Radiation calculation complete!", "info");
        }

        // ==========================================
        // Module: Spacetime Curvature Model (Advanced Module)
        // ==========================================
        function displayCurvature() {
            const k = parseInt(document.querySelector('input[name="curv"]:checked').value);
            let description = '';
            if (k === 1) description = 'Closed universe with positive curvature (spherical). Light rays converge, finite volume.';
            else if (k === -1) description = 'Open universe with negative curvature (hyperbolic). Light rays diverge, infinite volume.';
            else description = 'Asymmetric spacetime curvature with entropy perturbation (flat-like with local distortions). Light rays behave locally complex, overall Euclidean-like.';
            curvatureOutput.textContent = description;
            showMessage("Spacetime Curvature simulation complete!", "info");
        }

        // ==========================================
        // Module: Dark Biology Simulation (Advanced Module)
        // ==========================================
        function simulateBiology() {
            // Validate inputs
            const gradValid = validateNumericInput(entropyGradInput, entropyGrad_error_span, "Entropy Gradient");
            const lambdaValid = validateNumericInput(lambdaBioInput, lambdaBio_error_span, "Lambda (Suppression Factor)");
            if (!gradValid || !lambdaValid) {
                showMessage("Please correct Dark Biology input errors.", "error", 4000);
                return;
            }

            const grad = parseFloat(entropyGradInput.value);
            const lambda = parseFloat(lambdaBioInput.value);
            if (grad >= 0) {
                bioOutput.textContent = '∇S ≥ 0 → No dark bio-potential. Dark biology is hypothesized to thrive in environments with sufficient negative entropy gradients.';
                showMessage("Dark Biology: No bio-potential due to positive/zero entropy gradient.", "warning");
                return;
            }
            const delta = 1.0; // Conceptual baseline bio-potential
            // P = delta * exp(-lambda * |∇S|)
            const P = delta * Math.exp(-lambda * Math.abs(grad));
            bioOutput.textContent = `Estimated dark bio-potential: P ≈ ${P.toFixed(6)}. This is a conceptual value, not empirically verified.`;
            showMessage("Dark Biology simulation complete!", "info");
        }

        // ==========================================
        // Module: DUT Quantum Mirror Experiment (Advanced Module)
        // ==========================================
        function simulateMirror() {
            // Validate inputs
            const D_valid = validateNumericInput(D_mirrorInput, D_mirror_error_span, "Distance D", false);
            const gradS_valid = validateNumericInput(gradS_mirrorInput, gradS_mirror_error_span, "Entropy Gradient", false);
            const deltaG_valid = validateNumericInput(deltaG_mirrorInput, deltaG_mirror_error_span, "Local Gravity Perturbation", false);
            const eta_valid = validateNumericInput(eta_mirrorInput, eta_mirror_error_span, "Reality Deformation Factor", false);

            if (!D_valid || !gradS_valid || !deltaG_valid || !eta_valid) {
                showMessage("Please correct the Quantum Mirror Experiment input errors.", "error", 5000);
                return;
            }

            const D_ly = parseFloat(D_mirrorInput.value);
            const gradS_kB = parseFloat(gradS_mirrorInput.value);
            const deltaG_pert = parseFloat(deltaG_mirrorInput.value);
            const eta_deform = parseFloat(eta_mirrorInput.value);

            // Constants used in this specific module, harmonized with main physics constants
            const c_ms = C; // Speed of light in m/s (from main constants)
            const hbar_js = HBAR; // Reduced Planck constant in J·s (from main constants)
            const kB_jk = KB; // Boltzmann constant in J/K (from main constants)

            // Convert distance D from light-years to meters
            const D_meters = D_ly * LIGHT_YEAR_TO_METERS;

            // Calculate classical light travel time (round trip)
            const t_light_seconds = (2 * D_meters) / c_ms;

            // Calculate entropy-induced delay (conceptual, using absolute value of gradS for time calculation)
            // Ensure gradS_kB is not zero to avoid division by zero.
            const t_entropy_seconds = Math.abs(gradS_kB) > 1e-20 ? Math.abs(hbar_js / (kB_jk * gradS_kB)) : 0;

            // Calculate gravitational distortion delay (conceptual)
            // Scaling factor adjusted for plausible results given the conceptual nature
            const t_deform_seconds = eta_deform * deltaG_pert * 1e12; // Adjusted scaling factor for more impact

            const totalDelay_seconds = t_light_seconds + t_entropy_seconds + t_deform_seconds;

            mirrorOutput.textContent =
                `Estimated Delay (Δt_obs):\n` +
                `- Light round-trip: ${t_light_seconds.toExponential(3)} s\n` +
                `- Entropy deformation: ${t_entropy_seconds.toExponential(3)} s\n` +
                `- Gravitational distortion: ${t_deform_seconds.toExponential(3)} s\n` +
                `\nTotal perceived reflection delay: ${totalDelay_seconds.toExponential(3)} seconds.`;

            showMessage("Quantum Mirror Experiment simulation complete!", "info");
        }


        // ==========================================
        // Module: Patch: Cosmic Time by Redshift (Integrated into Fossil Record)
        // ==========================================
        function computeFossilTime() {
            // Validate input
            const zValid = validateNumericInput(z_fossil_newInput, z_fossil_new_error_span, "Redshift z");
            if (!zValid) {
                showMessage("Please correct Redshift input error for Cosmic Time calculation.", "error", 4000);
                // Clear output if input invalid
                fossilTimeOutput.textContent = `Estimated cosmic time at z=${z_fossil_newInput.value}: ≈ -- Gyr`;
                fossilTimeCtx.clearRect(0,0,fossilTimeCanvas.width, fossilTimeCanvas.height);
                return;
            }

            const z = parseFloat(z_fossil_newInput.value);
            // Constants from the provided patch (different from main H0)
            const H0_patch = H0_PATCH_KM_S_MPC; // km/s/Mpc

            // t_gyr = (978 / H0_patch) * (2 / (3 * (1 + z)^1.5)) - This assumes a specific cosmological model.
            // Using a more standard flat Lambda-CDM approximation (Omega_M=0.3, Omega_Lambda=0.7) for t(z) is more complex.
            // Sticking to the provided simplified formula for consistency with your patch.
            // The factor 978/1000 in your original patch suggests (1/H0 in s) to Gyr, but in a simplified form.
            // Let's use the explicit conversion of H0 to 1/Gyr for clarity and correctness with the formula structure.
            // H0_in_Gyr_inv = H0_patch (km/s/Mpc) * (3.086e19 km/Mpc) / (3.154e16 s/Gyr) = H0_patch * 0.9778 Gyr^-1
            const t_gyr = (978 / H0_patch) * (2 / (3 * Math.pow(1 + z, 1.5)));

            fossilTimeOutput.textContent = `Estimated cosmic time at z=${z}: ≈ ${t_gyr.toFixed(2)} Gyr.`;
            showMessage("Cosmic time at Redshift calculated!", "info");
            drawFossilTimePlot(z_fossil_newInput.value); // Draw the plot
            // Update the main fossil results display if in that mode
            if (currentSimulationMode === 'fossil' && dutFossilSimInstance) {
                dutFossilSimInstance.displayResults();
            }
        }

        /* NEW FUNCTION: Draws the Cosmic Time vs. Redshift Plot */
        function drawFossilTimePlot(currentZValue) {
            fossilTimeCtx.clearRect(0, 0, fossilTimeCanvas.width, fossilTimeCanvas.height);

            const margin = 30;
            const plotWidth = fossilTimeCanvas.width - 2 * margin;
            const plotHeight = fossilTimeCanvas.height - 2 * margin;

            const H0_patch = H0_PATCH_KM_S_MPC;
            const maxZ = 60; // Max redshift to plot
            const maxTimeGyr = (978 / H0_patch); // Approx. age of universe at z=0 (max Y value for scaling)

            // Draw axes
            fossilTimeCtx.strokeStyle = varCss('--axis-color');
            fossilTimeCtx.lineWidth = 1;
            fossilTimeCtx.beginPath();
            fossilTimeCtx.moveTo(margin, fossilTimeCanvas.height - margin); // X-axis
            fossilTimeCtx.lineTo(fossilTimeCanvas.width - margin, fossilTimeCanvas.height - margin);
            fossilTimeCtx.moveTo(margin, fossilTimeCanvas.height - margin); // Y-axis
            fossilTimeCtx.lineTo(margin, margin);
            fossilTimeCtx.stroke();

            // Draw labels
            fossilTimeCtx.fillStyle = varCss('--text-color-secondary');
            fossilTimeCtx.font = '10px Arial';
            fossilTimeCtx.textAlign = 'center';
            fossilTimeCtx.fillText('Redshift (z)', fossilTimeCanvas.width / 2, fossilTimeCanvas.height - 5);
            fossilTimeCtx.save();
            fossilTimeCtx.translate(15, fossilTimeCanvas.height / 2);
            fossilTimeCtx.rotate(-Math.PI / 2);
            fossilTimeCtx.fillText('Cosmic Time (Gyr)', 0, 0);
            fossilTimeCtx.restore();

            // X-axis ticks (redshift)
            for (let i = 0; i <= 6; i++) { // 0, 10, 20, ..., 60
                const zTick = i * 10;
                const x = margin + (zTick / maxZ) * plotWidth;
                fossilTimeCtx.fillText(zTick, x, fossilTimeCanvas.height - margin + 15);
            }

            // Y-axis ticks (cosmic time)
            for (let i = 0; i <= 4; i++) { // 0, 1/4, 1/2, 3/4, 1 of maxTimeGyr
                const timeTickVal = (i / 4) * maxTimeGyr;
                const y = fossilTimeCanvas.height - margin - (i / 4) * plotHeight;
                fossilTimeCtx.fillText(timeTickVal.toFixed(1), margin - 10, y + 3);
            }

            fossilTimeCtx.beginPath();
            fossilTimeCtx.strokeStyle = '#63b3ed'; // Blue for curve
            fossilTimeCtx.lineWidth = 2;

            const numPoints = 100;
            for (let i = 0; i <= numPoints; i++) {
                const z = (i / numPoints) * maxZ; // Vary redshift from 0 to maxZ
                const t_gyr = (978 / H0_patch) * (2 / (3 * Math.pow(1 + z, 1.5)));

                const xPos = margin + (z / maxZ) * plotWidth;
                const yPos = fossilTimeCanvas.height - margin - (t_gyr / maxTimeGyr) * plotHeight;

                if (i === 0) fossilTimeCtx.moveTo(xPos, yPos);
                else fossilTimeCtx.lineTo(xPos, yPos);
            }
            fossilTimeCtx.stroke();

            // Highlight current Z value if it's within plot range
            const currentZ = parseFloat(currentZValue);
            if (!isNaN(currentZ) && currentZ >= 0 && currentZ <= maxZ) {
                const currentX = margin + (currentZ / maxZ) * plotWidth;
                const currentT = (978 / H0_patch) * (2 / (3 * Math.pow(1 + currentZ, 1.5)));
                const currentY = fossilTimeCtx.height - margin - (currentT / maxTimeGyr) * plotHeight;

                fossilTimeCtx.fillStyle = '#FF4500'; // Orange-red
                fossilTimeCtx.beginPath();
                fossilTimeCtx.arc(currentX, currentY, 5, 0, 2 * Math.PI);
                fossilTimeCtx.fill();
                fossilTimeCtx.fillText(`z=${currentZ.toFixed(1)}`, currentX + 15, currentY - 5);
                fossilTimeCtx.fillText(`${currentT.toFixed(2)} Gyr`, currentX + 15, currentY + 15);
            }
        }

        // ==========================================
        // Module: Patch: DUT Regime Validity Score (Integrated into Consistency Check)
        // ==========================================
        function checkRegimeValidity() {
            const z_valid = validateNumericInput(z_consist_newInput, z_consist_new_error_span, "Maximum Redshift");
            const m_valid = validateNumericInput(m_consist_newInput, m_consist_new_error_span, "Minimum Observed Mass");

            if (!z_valid || !m_valid) {
                showMessage("Please correct input errors for Regime Validity Check.", "error", 4000);
                return;
            }

            const z = parseFloat(z_consist_newInput.value);
            const M = parseFloat(m_consist_newInput.value); // M in solar masses

            let score = 100; // Start with full score

            // Penalties based on provided logic
            if (z > 30) {
                score -= 30; // High redshift penalty (e.g., beyond current observational/theoretical reach)
            }
            if (M < 1e7) {
                score -= 40; // Very low mass penalty (e.g., difficult to form structures in DUT)
            }
            if (z < 3) {
                score -= 20; // Low redshift penalty (e.g., less relevance for early universe theories)
            }

            // Ensure score is within 0-100
            score = Math.max(0, Math.min(100, score));

            const phrase = score > 80 ? "✅ Model valid in this regime." : "⚠️ DUT enters speculative zone.";
            consistencyOutput.textContent = `Regime Validity Score: ${score}/100\n${phrase}`;
            showMessage("DUT Regime Validity Check complete!", "info");
        }


        // Helper to get CSS variable values
        function varCss(name) {
            return getComputedStyle(document.documentElement).getPropertyValue(name);
        }

        // ==========================================
        // Module: Event Listeners and Initialization
        // ==========================================
        document.addEventListener('DOMContentLoaded', async () => {
            // Setup slider value displays
            [
                { slider: amplitudeSlider, span: amplitudeValueSpan },
                { slider: frequencySlider, span: frequencyValueSpan },
                { slider: decaySlider, span: decayValueSpan, fixed: 2 },
                { slider: centralSlider, span: centralValueSpan },
                { slider: radiusSlider, span: radiusValueSpan },
                { slider: densitySlider, span: densityValueSpan },
                { slider: simTimeSlider, span: simTimeValSpan, fixed: 1 },
                { slider: thermoGravityFactorSlider, span: thermoGravityFactorValSpan, fixed: 2 },
                { slider: entropyEvolutionRateSlider, span: entropyEvolutionRateValSpan, fixed: 3 },
                { slider: decoherenceCouplingFactorSlider, span: decoherenceCouplingFactorValSpan, fixed: 1 }
            ].forEach(({ slider, span, fixed }) => {
                const update = () => span.textContent = fixed ? parseFloat(slider.value).toFixed(fixed) : slider.value;
                slider.addEventListener('input', update);
                update(); // Initial update
            });

            // Setup input number value displays and validation
            [
                { input: fossil_t0_input, span: fossil_t0_val_span, error: fossil_t0_error_span, name: "Initial Time" },
                { input: fossil_tmax_input, span: fossil_tmax_val_span, error: fossil_tmax_error_span, name: "Max Time" },
                { input: fossil_dt_input, span: fossil_dt_val_span, error: fossil_dt_error_span, name: "Time Step" },
                { input: fossil_beta_input, span: fossil_beta_val_span, error: fossil_beta_error_span, name: "Population Decay Rate" },
                { input: galactic_alpha_input, span: galactic_alpha_val_span, error: galactic_alpha_error_span, name: "Quenching Rate" },
                { input: galactic_N0_input, span: galactic_N0_val_span, error: galactic_N0_error_span, name: "Initial Active Galaxies", format: (val) => parseFloat(val).toLocaleString() },
                { input: galactic_Nf_dot_input, span: galactic_Nf_dot_val_span, error: galactic_Nf_dot_error_span, name: "New Galaxy Formation Rate", format: (val) => parseFloat(val).toLocaleString() },
                { input: galactic_total_time_input, span: galactic_total_time_val_span, error: galactic_total_time_error_span, name: "Total Simulation Time" },
                { input: galactic_dt_input, span: galactic_dt_val_span, error: galactic_dt_error_span, name: "Time Step" },
                { input: retraction_tmax_input, span: retraction_tmax_val_span, error: retraction_tmax_error_span, name: "Retraction Max Time" },
                { input: retraction_dt_input, span: retraction_dt_val_span, error: retraction_dt_error_span, name: "Retraction Time Step" },
                { input: retraction_beta_input, span: retraction_beta_val_span, error: retraction_beta_error_span, name: "Retraction Factor" },
                // Auto-Refutation inputs (allowing empty for default 0)
                { input: predictedEventsInput, error: predictedEventsErrorSpan, name: "Predicted Events", allowEmpty: true },
                { input: confirmedEventsInput, error: confirmedEventsErrorSpan, name: "Confirmed Events", allowEmpty: true },
                { input: falsifiedEventsInput, error: falsifiedEventsErrorSpan, name: "Falsified Events", allowEmpty: true },
                // NEW Advanced Modules inputs
                { input: betaSRDInput, error: betaSRD_error_span, name: "SRD Beta" },
                { input: gammaSRDInput, error: gammaSRD_error_span, name: "SRD Gamma" },
                { input: N0_galaxy_dating_input, error: N0_galaxy_dating_error_span, name: "Galaxy Dating N0" },
                { input: beta_galaxy_dating_input, error: beta_galaxy_dating_error_span, name: "Galaxy Dating Decay Beta" },
                { input: duration_galaxy_dating_input, error: duration_galaxy_dating_error_span, name: "Galaxy Dating Duration" },
                { input: entropyGradInput, error: entropyGrad_error_span, name: "Entropy Gradient" },
                { input: lambdaBioInput, error: lambdaBio_error_span, name: "Lambda Biology" },
                // NEW Quantum Mirror Module inputs
                { input: D_mirrorInput, error: D_mirror_error_span, name: "Mirror Distance D" },
                { input: gradS_mirrorInput, error: gradS_mirror_error_span, name: "Mirror Entropy GradS" },
                { input: deltaG_mirrorInput, error: deltaG_mirror_error_span, name: "Mirror Delta G" },
                { input: eta_mirrorInput, error: eta_mirror_error_span, name: "Mirror Reality Factor" },
                // NEW Patch Modules inputs
                { input: z_fossil_newInput, error: z_fossil_new_error_span, name: "Cosmic Time Redshift" }, // For new fossil time calc
                { input: simDataManualInput, error: simDataManual_error_span, name: "Manual Hash Data", allowEmpty: true }, // For manual hashing textarea
                { input: z_consist_newInput, error: z_consist_new_error_span, name: "Regime Check zMax" }, // For regime validity
                { input: m_consist_newInput, error: m_consist_new_error_span, name: "Regime Check Min Mass" }, // For regime validity
                // NEW Advanced Fossil Module inputs
                { input: mass_fossil_adv_input, error: mass_fossil_adv_error_span, name: "Advanced Fossil Mass" }
            ].forEach(({ input, span, error, name, format, allowEmpty = false }) => {
                const update = () => {
                    if (span) span.textContent = format ? format(input.value) : input.value;
                    validateNumericInput(input, error, name, allowEmpty);
                };
                input.addEventListener('input', update);
                input.addEventListener('change', update);
                update();
            });


            // Mode selection logic
            const allControlPanels = [
                potentialControlsDiv, fossilControlsDiv, galacticControlsDiv, retractionControlsDiv,
                document.getElementById('srdModulePanel'),
                document.getElementById('galaxyBirthDeathDatingModulePanel'), // Updated ID
                document.getElementById('cosmicFossilRecordSimulatorAdvancedPanel'), // Updated ID
                document.getElementById('hawkingRadiationModulePanel'),
                document.getElementById('curvatureModulePanel'),
                document.getElementById('darkBiologyModulePanel'),
                document.getElementById('mirrorModulePanel')
            ];
            const allResultsBoxes = [potentialResultsBox, fossilResultsBox, galacticResultsBox, retractionResultsBox];

            allModeButtons.forEach(button => {
                button.addEventListener('click', () => {
                    allModeButtons.forEach(btn => btn.classList.remove('active'));
                    button.classList.add('active');

                    // Hide all control panels and result boxes first
                    allControlPanels.forEach(panel => panel.classList.add('hidden'));
                    allResultsBoxes.forEach(box => box.classList.add('hidden'));

                    // Ensure animation is stopped when changing modes
                    if (isAnimating) {
                        isAnimating = false;
                        if (animationFrameId) {
                            cancelAnimationFrame(animationFrameId);
                            animationFrameId = null;
                        }
                        animateButton.classList.remove('active');
                        mode1DButton.classList.add('active'); // Revert to 1D view state
                    }


                    if (button.id === 'modePotentialBtn') {
                        currentSimulationMode = 'potential';
                        potentialControlsDiv.classList.remove('hidden');
                        potentialResultsBox.classList.remove('hidden');
                        commonInfoBox.classList.add('active'); // Show info for potential
                        drawGravitationalMetricsAndEntropicFields();
                    } else if (button.id === 'modeFossilBtn') {
                        currentSimulationMode = 'fossil';
                        fossilControlsDiv.classList.remove('hidden');
                        fossilResultsBox.classList.remove('hidden');
                        commonInfoBox.classList.remove('active'); // Hide info for other modes
                        // Ensure computeFossilTime is run so fossilResultsDiv is updated
                        computeFossilTime(); // Also updates the canvas
                        if (dutFossilSimInstance) dutFossilSimInstance.displayResults();
                    } else if (button.id === 'modeGalacticBtn') {
                        currentSimulationMode = 'galactic';
                        galacticControlsDiv.classList.remove('hidden');
                        galacticResultsBox.classList.remove('hidden');
                        commonInfoBox.classList.remove('active'); // Hide info for other modes
                        // Ensure plot is drawn on module activation
                        if (galacticEvolutionSimInstance) {
                            drawGalacticEvolutionPlotOriginal(galacticEvolutionSimInstance.results);
                        } else {
                            // If no instance, draw with default values (run a dummy sim to get data)
                            const alpha = parseFloat(galactic_alpha_input.value);
                            const N0 = parseFloat(galactic_N0_input.value);
                            const Nf_dot = parseFloat(galactic_Nf_dot_input.value);
                            const total_time = parseFloat(galactic_total_time_input.value);
                            const dt = parseFloat(galactic_dt_input.value);
                            const tempSim = new GalacticEvolutionSimulator(alpha, N0, Nf_dot, total_time, dt);
                            tempSim.runSimulation(); // Run to populate results
                            drawGalacticEvolutionPlotOriginal(tempSim.results);
                        }
                        if (galacticEvolutionSimInstance) galacticEvolutionSimInstance.displayResults();
                    } else if (button.id === 'modeRetractionBtn') {
                        currentSimulationMode = 'retraction';
                        retractionControlsDiv.classList.remove('hidden');
                        retractionResultsBox.classList.remove('hidden');
                        commonInfoBox.classList.remove('active');
                        if (dutRetractionSimInstance) {
                            dutRetractionSimInstance.displayResults(); // Calls drawRetractionPlot internally
                        } else {
                            // If no instance, draw with default values
                            drawRetractionPlot();
                        }
                    }
                });
            });

            // Gravitational Potential Event Listeners
            [amplitudeSlider, frequencySlider, decaySlider, centralSlider, radiusSlider, densitySlider, simTimeSlider, thermoGravityFactorSlider, entropyEvolutionRateSlider, decoherenceCouplingFactorSlider].forEach(slider => {
                slider.addEventListener('input', () => {
                    if (!isAnimating) { // Only redraw immediately if not animating
                        drawGravitationalMetricsAndEntropicFields();
                    }
                });
            });

            animateButton.addEventListener('click', () => {
                isAnimating = !isAnimating;
                if (isAnimating) {
                    animateButton.classList.add('active');
                    mode1DButton.classList.remove('active');
                    animateGravitationalMetricsAndEntropicFields();
                } else {
                    animateButton.classList.remove('active');
                    // Keep mode1DButton active if animation stops naturally or manually
                }
            });

            resetButton.addEventListener('click', () => {
                isAnimating = false;
                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                    animationFrameId = null;
                }
                phase = 0;
                globalTime = 0; // Reset global time
                // Reset sliders to default values
                amplitudeSlider.value = 1;
                frequencySlider.value = 3;
                decaySlider.value = 0.1;
                centralSlider.value = -1;
                radiusSlider.value = 1;
                densitySlider.value = 5;
                simTimeSlider.value = 0;
                thermoGravityFactorSlider.value = 0.1;
                entropyEvolutionRateSlider.value = 0.01;
                decoherenceCouplingFactorSlider.value = 1.0;
                // Update display values
                amplitudeValueSpan.textContent = '1.0';
                frequencyValueSpan.textContent = '3.0';
                decayValueSpan.textContent = '0.10';
                centralValueSpan.textContent = '-1.0';
                radiusValueSpan.textContent = '1.0';
                densityValueSpan.textContent = '5.0';
                simTimeValSpan.textContent = '0.0';
                thermoGravityFactorValSpan.textContent = '0.1';
                entropyEvolutionRateValSpan.textContent = '0.01';
                decoherenceCouplingFactorValSpan.textContent = '1.0';
                drawGravitationalMetricsAndEntropicFields();
                animateButton.classList.remove('active');
                mode1DButton.classList.add('active');
            });

            exportPotentialCSVBtn.addEventListener('click', () => {
                // Ensure results are up-to-date before export
                drawGravitationalMetricsAndEntropicFields();
                const data = [{
                    "Core Temperature (K)": currentPotentialResults.T_core,
                    "Core Mass (Solar Masses)": currentPotentialResults.M_core / SOLAR_MASS,
                    "Spatial Curvature (Omega_k)": currentPotentialResults.Omega_k,
                    "Amplitude (V0)": currentPotentialResults.V0,
                    "Frequency (omega)": currentPotentialResults.omega,
                    "Decay (alpha)": currentPotentialResults.alpha,
                    "Central Potential (beta)": currentPotentialResults.beta,
                    "Core Size Factor (R_core)": currentPotentialResults.R_core_factor,
                    "Central Density Factor (rho_0)": currentPotentialResults.rho_0_factor,
                    "Simulation Time (Gyr)": currentPotentialResults.sim_time,
                    "Thermo Gravity Factor (k_TG)": currentPotentialResults.thermo_gravity_factor,
                    "Entropy Evolution Rate (nu_S)": currentPotentialResults.entropy_evolution_rate,
                    "Decoherence Coupling Factor (k_Decoh)": currentPotentialResults.decoherence_coupling_factor,
                    "g_tt_at_Rcore": currentPotentialResults.gtt_at_Rcore,
                    "g_rr_at_Rcore": currentPotentialResults.grr_at_Rcore,
                    "Proper_Time_Dilation_at_Rcore": currentPotentialResults.proper_time_dilation_at_Rcore,
                    "Quantum_Decoherence_Rate_at_Rcore_Hz": currentPotentialResults.quantum_decoherence_rate_at_Rcore,
                    "Total_Stress_Energy_at_Rcore_kg_per_m3": currentPotentialResults.total_stress_energy_at_Rcore
                }];
                exportToCSV(data, 'dut_potential_metrics_results.csv', [
                    "Core Temperature (K)", "Core Mass (Solar Masses)", "Spatial Curvature (Omega_k)",
                    "Amplitude (V0)", "Frequency (omega)", "Decay (alpha)",
                    "Central Potential (beta)", "Core Size Factor (R_core)", "Central Density Factor (rho_0)",
                    "Simulation Time (Gyr)", "Thermo Gravity Factor (k_TG)", "Entropy Evolution Rate (nu_S)", "Decoherence Coupling Factor (k_Decoh)",
                    "g_tt_at_Rcore", "g_rr_at_Rcore", "Proper_Time_Dilation_at_Rcore", "Quantum_Decoherence_Rate_at_Rcore_Hz", "Total_Stress_Energy_at_Rcore_kg_per_m3"
                ]);
            });

            // Cosmic Fossil Record Event Listeners
            runFossilSimBtn.addEventListener('click', () => {
                try {
                    // Re-validate all inputs before running simulation
                    const t0Valid = validateNumericInput(fossil_t0_input, fossil_t0_error_span, "Initial Time");
                    const tmaxValid = validateNumericInput(fossil_tmax_input, fossil_tmax_error_span, "Max Time");
                    const dtValid = validateNumericInput(fossil_dt_input, fossil_dt_error_span, "Time Step");
                    const betaValid = validateNumericInput(fossil_beta_input, fossil_beta_error_span, "Population Decay Rate");

                    if (!t0Valid || !tmaxValid || !dtValid || !betaValid) {
                        showMessage("Please correct the invalid input parameters.", "error", 4000);
                        return;
                    }

                    const t0 = parseFloat(fossil_t0_input.value);
                    const tmax = parseFloat(fossil_tmax_input.value);
                    const dt = parseFloat(fossil_dt_input.value);
                    const beta = parseFloat(fossil_beta_input.value);

                    dutFossilSimInstance = new DUTFossilSimulator(t0, tmax, dt, beta);
                    dutFossilSimInstance.runSimulation();
                    dutFossilSimInstance.displayResults(); // This now updates with the patch result
                    showMessage("Cosmic Fossil Record simulation completed!", "info");
                } catch (error) {
                    showMessage("Simulation Error: " + error.message, "error", 5000);
                    console.error("Fossil Simulation Error:", error);
                }
            });

            resetFossilBtn.addEventListener('click', () => {
                fossil_t0_input.value = 13.8;
                fossil_tmax_input.value = 200;
                fossil_dt_input.value = 0.1;
                fossil_beta_input.value = 0.03;
                fossil_t0_val_span.textContent = '13.8';
                fossil_tmax_val_span.textContent = '200';
                fossil_dt_val_span.textContent = '0.1';
                fossil_beta_val_span.textContent = '0.03';
                // Patch module reset
                z_fossil_newInput.value = 5;
                z_fossil_new_error_span.textContent = '';
                z_fossil_newInput.classList.remove('input-error');
                fossilTimeOutput.textContent = `Estimated cosmic time at z=5: ≈ -- Gyr`;
                fossilTimeCtx.clearRect(0,0,fossilTimeCanvas.width, fossilTimeCanvas.height); // Clear canvas

                // Clear any error messages
                fossil_t0_error_span.textContent = '';
                fossil_tmax_error_span.textContent = '';
                fossil_dt_error_span.textContent = '';
                fossil_beta_error_span.textContent = '';
                fossil_t0_input.classList.remove('input-error');
                fossil_tmax_input.classList.remove('input-error');
                fossil_dt_input.classList.remove('input-error');
                fossil_beta_input.classList.remove('input-error');

                fossilResultsDiv.innerHTML = `
                    Estimated Cosmic Energy Extinction Time: -- Gyr<br>
                    Final Usable Energy: -- (Normalized Units)<br>
                    Final Cold Gas Mass: -- (Normalized Units)<br><br>
                    Calculated Cosmic Time at Redshift:<br>
                    Estimated cosmic time at z=5: ≈ -- Gyr
                `;
                dutFossilSimInstance = null; // Clear instance
                showMessage("Cosmic Fossil Record parameters reset.", "info");
            });

            exportFossilCSVBtn.addEventListener('click', () => {
                if (dutFossilSimInstance && dutFossilSimInstance.results.length > 0) {
                    exportToCSV(dutFossilSimInstance.getCSVData(), 'dut_fossil_simulation_data.csv', ["Time_Gyr", "Usable_Energy", "Cold_Gas_Mass"]);
                } else {
                    showMessage("Run the Cosmic Fossil Record simulation first to export data!", "error");
                }
            });

            // Patch: Cosmic Time Calculation by Redshift Listener
            computeFossilTimeBtn.addEventListener('click', computeFossilTime);
            // Also update when input changes
            z_fossil_newInput.addEventListener('input', computeFossilTime);


            // Galactic Evolution Event Listeners
            runGalacticSimBtn.addEventListener('click', () => {
                try {
                    // Re-validate all inputs before running simulation
                    const alphaValid = validateNumericInput(galactic_alpha_input, galactic_alpha_error_span, "Quenching Rate");
                    const N0Valid = validateNumericInput(galactic_N0_input, galactic_N0_error_span, "Initial Active Galaxies");
                    const NfDotValid = validateNumericInput(galactic_Nf_dot_input, galactic_Nf_dot_error_span, "New Galaxy Formation Rate");
                    const totalTimeValid = validateNumericInput(galactic_total_time_input, galactic_total_time_error_span, "Total Simulation Time");
                    const dtValid = validateNumericInput(galactic_dt_input, galactic_dt_error_span, "Time Step");

                    if (!alphaValid || !N0Valid || !NfDotValid || !totalTimeValid || !dtValid) {
                        showMessage("Please correct the invalid input parameters.", "error", 4000);
                        return;
                    }

                    const alpha = parseFloat(galactic_alpha_input.value);
                    const N0 = parseFloat(galactic_N0_input.value);
                    const Nf_dot = parseFloat(galactic_Nf_dot_input.value);
                    const total_time = parseFloat(galactic_total_time_input.value);
                    const dt = parseFloat(galactic_dt_input.value);

                    galacticEvolutionSimInstance = new GalacticEvolutionSimulator(alpha, N0, Nf_dot, total_time, dt);
                    galacticEvolutionSimInstance.runSimulation();
                    galacticEvolutionSimInstance.displayResults();
                    // Redraw plot after simulation if values change
                    drawGalacticEvolutionPlotOriginal(galacticEvolutionSimInstance.results);
                    showMessage("Galactic Evolution simulation completed!", "info");
                } catch (error) {
                    showMessage("Simulation Error: " + error.message, "error", 5000);
                    console.error("Galactic Simulation Error:", error);
                }
            });

            resetGalacticBtn.addEventListener('click', () => {
                galactic_alpha_input.value = 0.25;
                galactic_N0_input.value = 2000000000000;
                galactic_Nf_dot_input.value = 5000000000;
                galactic_total_time_input.value = 120;
                galactic_dt_input.value = 1.0;
                galactic_alpha_val_span.textContent = '0.25';
                galactic_N0_val_span.textContent = '2,000,000,000,000';
                galactic_Nf_dot_val_span.textContent = '5,000,000,000';
                galactic_total_time_val_span.textContent = '120';
                galactic_dt_val_span.textContent = '1.0';
                // Clear any error messages
                galactic_alpha_error_span.textContent = '';
                galactic_N0_error_span.textContent = '';
                galactic_Nf_dot_error_span.textContent = '';
                galactic_total_time_error_span.textContent = '';
                galactic_dt_error_span.textContent = '';
                galactic_alpha_input.classList.remove('input-error');
                galactic_N0_input.classList.remove('input-error');
                galactic_Nf_dot_input.classList.remove('input-error');
                galactic_total_time_input.classList.remove('input-error');
                galactic_dt_input.classList.remove('input-error');

                galacticResultsDiv.innerHTML = `
                    Initial Active Galaxies: -- <br>
                    Final Active Galaxies: --
                `;
                galacticEvolutionSimInstance = null; // Clear instance
                galacticEvolutionCtxOriginal.clearRect(0,0,galacticEvolutionCanvasOriginal.width, galacticEvolutionCanvasOriginal.height); // Clear canvas
                showMessage("Galactic Evolution parameters reset.", "info");
            });

            exportGalacticCSVBtn.addEventListener('click', () => {
                if (galacticEvolutionSimInstance && galacticEvolutionSimInstance.results.length > 0) {
                    exportToCSV(galacticEvolutionSimInstance.getCSVData(), 'dut_galactic_simulation_data.csv', ["Time_Gyr", "Active_Galaxies"]);
                } else {
                    showMessage("Run the Galactic Evolution simulation first to export data!", "error");
                }
            });

            // Thermodynamic Retraction Event Listeners (NEW)
            runRetractionSimBtn.addEventListener('click', () => {
                try {
                    const tmaxValid = validateNumericInput(retraction_tmax_input, retraction_tmax_error_span, "Max Time");
                    const dtValid = validateNumericInput(retraction_dt_input, retraction_dt_error_span, "Time Step");
                    const betaValid = validateNumericInput(retraction_beta_input, retraction_beta_error_span, "Retraction Factor");

                    if (!tmaxValid || !dtValid || !betaValid) {
                        showMessage("Please correct the invalid input parameters for Thermodynamic Retraction.", "error", 4000);
                        return;
                    }

                    const t_max = parseFloat(retraction_tmax_input.value);
                    const dt = parseFloat(retraction_dt_input.value);
                    const beta_retraction = parseFloat(retraction_beta_input.value);

                    dutRetractionSimInstance = new DUTRetractionSimulator(t_max, dt, beta_retraction);
                    dutRetractionSimInstance.runSimulation();
                    dutRetractionSimInstance.displayResults();
                    showMessage("Thermodynamic Retraction simulation completed!", "info");
                } catch (error) {
                    showMessage("Simulation Error: " + error.message, "error", 5000);
                    console.error("Retraction Simulation Error:", error);
                }
            });

            resetRetractionBtn.addEventListener('click', () => {
                retraction_tmax_input.value = 500;
                retraction_dt_input.value = 1.0;
                retraction_beta_input.value = 0.05;
                retraction_tmax_val_span.textContent = '500';
                retraction_dt_val_span.textContent = '1.0';
                retraction_beta_val_span.textContent = '0.05';
                // Clear any error messages
                retraction_tmax_error_span.textContent = '';
                retraction_dt_error_span.textContent = '';
                retraction_beta_error_span.textContent = '';
                retraction_tmax_input.classList.remove('input-error');
                retraction_dt_input.classList.remove('input-error');
                retraction_beta_input.classList.remove('input-error');

                retractionResultsDiv.innerHTML = `
                    Total Simulated Time: -- Gyr<br>
                    Final Observable Volume: -- (Normalized)
                `;
                dutRetractionSimInstance = null;
                retractionCtx.clearRect(0,0,retractionCanvas.width, retractionCanvas.height); // Clear canvas
                showMessage("Thermodynamic Retraction parameters reset.", "info");
            });

            exportRetractionCSVBtn.addEventListener('click', () => {
                if (dutRetractionSimInstance && dutRetractionSimInstance.results.length > 0) {
                    exportToCSV(dutRetractionSimInstance.getCSVData(), 'dut_retraction_simulation_data.csv', ["Time_Gyr", "Observable_Volume"]);
                } else {
                    showMessage("Run the Thermodynamic Retraction simulation first to export data!", "error");
                }
            });


            // Local Ledger Event Listeners
            recordDataBtn.addEventListener('click', recordCurrentDataToLedger);
            viewLedgerBtn.addEventListener('click', viewLocalLedgerHistory);
            exportLedgerCSVBtn.addEventListener('click', exportLocalLedgerToCSV);
            clearLedgerBtn.addEventListener('click', clearLocalLedger);
            updateLedgerStatus(); // Initial update of ledger status

            // Patch: Manual Hashing Listener
            generateManualHashBtn.addEventListener('click', generateManualHash);
            // Clear hash output on textarea change
            simDataManualInput.addEventListener('input', () => { hashOutput.textContent = ''; });


            // Observational Data Event Listeners
            loadJWSTDataBtn.addEventListener('click', () => {
                try {
                    const data = ObservationalAPI.getJWSTGalaxyData();
                    if (data.length > 0) {
                        let displayText = "--- Simulated JWST Galaxy Data ---\n\n";
                        data.forEach(galaxy => {
                            displayText += `\nName: ${galaxy.name}\n`;
                            displayText += `  Redshift (z): ${galaxy.redshift}\n`;
                            displayText += `  Stellar Mass: ${galaxy.stellar_mass_solar.toExponential(2)} Solar Masses\n`;
                            displayText += `  sSFR: ${galaxy.sSFR_yr_inv.toExponential(2)} yr⁻¹\n`;
                            displayText += `  Morphology: ${galaxy.morphology}\n`;
                        });
                        observationalDataDisplay.textContent = displayText;
                        showMessage("Simulated JWST galaxy data loaded!", "info");
                    } else {
                        observationalDataDisplay.textContent = "No simulated JWST galaxy data available.";
                        showMessage("No simulated JWST galaxy data available.", "info");
                    }
                } catch (error) {
                    observationalDataDisplay.textContent = "Failed to load simulated JWST data.";
                    showMessage("Failed to load simulated JWST data: " + error.message, "error", 5000);
                    console.error("Error loading simulated JWST data:", error);
                }
            });

            loadNASAEarthDataBtn.addEventListener('click', () => {
                try {
                    const data = ObservationalAPI.getNASAEarthData();
                    if (data) {
                        let displayText = "--- Simulated NASA Earth Data ---\n\n";
                        for (const key in data) {
                            if (Object.hasOwnProperty.call(data, key)) {
                                const value = data[key];
                                if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
                                    displayText += `\n${key.replace(/_/g, ' ')}:\n`;
                                    for (const subKey in value) {
                                        displayText += `  ${subKey.replace(/_/g, ' ')}: ${value[subKey].toLocaleString()}\n`;
                                    }
                                } else if (Array.isArray(value)) {
                                    displayText += `\n${key.replace(/_/g, ' ')}:\n`;
                                    value.forEach(item => {
                                        displayText += `  - ${typeof item === 'object' ? JSON.stringify(item) : item}\n`;
                                    });
                                }
                                else {
                                    displayText += `\n${key.replace(/_/g, ' ')}: ${value}\n`;
                                }
                            }
                        }
                        observationalDataDisplay.textContent = displayText;
                        showMessage("Simulated NASA Earth data loaded!", "info");
                    } else {
                        observationalDataDisplay.textContent = "No simulated NASA Earth data available.";
                        showMessage("No simulated NASA Earth data available.", "info");
                    }
                } catch (error) {
                    observationalDataDisplay.textContent = "Failed to load simulated NASA Earth data.";
                    showMessage("Failed to load simulated NASA Earth data: " + error.message, "error", 5000);
                    console.error("Error loading simulated NASA Earth data:", error);
                }
            });

            // NEW: Event Listener for Import Data File button
            loadLocalFileBtn.addEventListener('click', () => {
                localFileInput.click(); // Trigger the hidden file input click
            });

            // NEW: Event Listener for when a file is selected
            localFileInput.addEventListener('change', (event) => {
                const file = event.target.files[0];
                if (!file) {
                    showMessage("No file selected.", "warning");
                    return;
                }

                const reader = new FileReader();
                reader.onload = (e) => {
                    const content = e.target.result;
                    let parsedData = null;
                    const filename = file.name;

                    try {
                        if (filename.endsWith('.json')) {
                            parsedData = JSON.parse(content);
                        } else if (filename.endsWith('.csv')) {
                            parsedData = parseCSV(content);
                        } else {
                            showMessage("Unsupported file type. Please select a .csv or .json file.", "error");
                            return;
                        }
                        displayImportedData(filename, parsedData);
                    } catch (parseError) {
                        showMessage(`Error parsing ${file.type} file: ${parseError.message}`, "error", 6000);
                        console.error(`Error parsing ${file.type} file:`, parseError);
                    }
                };

                reader.onerror = () => {
                    showMessage("Failed to read file.", "error");
                };

                reader.readAsText(file); // Read file content as text
            });


            // Consistency Check Event Listener (NEW)
            runConsistencyCheckBtn.addEventListener('click', scientificConsistencyCheck);
            // Patch: Regime Validity Check Listener
            checkConsistencyBtn.addEventListener('click', checkRegimeValidity);
            // Update Regime Validity on input change
            z_consist_newInput.addEventListener('input', checkRegimeValidity);
            m_consist_newInput.addEventListener('input', checkRegimeValidity);


            // AI Assistant Event Listener (NEW)
            runAIAssistantCheckBtn.addEventListener('click', runAIAssistantCheck);

            // Auto-Refutation Event Listeners (NEW)
            runRefutationBtn.addEventListener('click', runRefutationAnalysis);
            exportRefutationJSONBtn.addEventListener('click', exportRefutationJSON);
            exportRefutationTXTBtn.addEventListener('click', exportRefutationTXT);

            // Interactive Console Event Listeners (NEW)
            consoleInputBtn.addEventListener('click', () => {
                const command = consoleInput.value;
                if (command) {
                    processConsoleCommand(command);
                    consoleInput.value = ''; // Clear input field
                }
            });

            consoleInput.addEventListener('keypress', (event) => {
                if (event.key === 'Enter') {
                    consoleInputBtn.click(); // Simulate click on Enter key press
                }
            });

            // NEW Advanced Modules Event Listeners (from previous integration)
            plotSRDBtn.addEventListener('click', plotSRD);
            // Add input listeners for SRD to re-plot automatically
            betaSRDInput.addEventListener('input', plotSRD);
            gammaSRDInput.addEventListener('input', plotSRD);

            simulateGalaxyBirthDeathBtn_dating.addEventListener('click', simulateGalaxyBirthDeathDating);
            // Add input listeners for Galaxy Evolution (dating) to re-plot automatically
            N0_galaxy_dating_input.addEventListener('input', simulateGalaxyBirthDeathDating);
            beta_galaxy_dating_input.addEventListener('input', simulateGalaxyBirthDeathDating);
            duration_galaxy_dating_input.addEventListener('input', simulateGalaxyBirthDeathDating);
            rejuvenate_galaxy_dating_checkbox.addEventListener('change', simulateGalaxyBirthDeathDating);


            calcEvaporationBtn.addEventListener('click', calcEvaporation);
            displayCurvatureBtn.addEventListener('click', displayCurvature);
            simulateBiologyBtn.addEventListener('click', simulateBiology);

            // NEW Quantum Mirror Module Event Listener
            simulateMirrorBtn.addEventListener('click', simulateMirror);

            // NEW Advanced Cosmic Fossil Record Simulator Event Listeners
            simulateFossilsAdvancedBtn.addEventListener('click', simulateFossilsAdvanced);
            exportFossilDataAdvancedBtn.addEventListener('click', exportFossilDataAdvanced);
            mass_fossil_adv_input.addEventListener('input', simulateFossilsAdvanced);
            type_fossil_adv_select.addEventListener('change', simulateFossilsAdvanced);
            includeData_fossil_adv_checkbox.addEventListener('change', simulateFossilsAdvanced);


            // Initial plot for SRD module
            plotSRD();
            // Initial cosmic time calculation for fossil record module
            computeFossilTime();
            // Initial Galactic Evolution plot (original module)
            // Run a dummy simulation to populate data for initial plot
            const alpha = parseFloat(galactic_alpha_input.value);
            const N0 = parseFloat(galactic_N0_input.value);
            const Nf_dot = parseFloat(galactic_Nf_dot_input.value);
            const total_time = parseFloat(galactic_total_time_input.value);
            const dt = parseFloat(galactic_dt_input.value);
            galacticEvolutionSimInstance = new GalacticEvolutionSimulator(alpha, N0, Nf_dot, total_time, dt);
            galacticEvolutionSimInstance.runSimulation();
            drawGalacticEvolutionPlotOriginal(galacticEvolutionSimInstance.results);

            // Initial Thermodynamic Retraction plot
            drawRetractionPlot(); // Ensure this is also called initially or on module selection

            // Initial Galaxy Birth-Death Dating Model plot
            simulateGalaxyBirthDeathDating(); // Call to draw initial plot for the new module

            // Initial Advanced Cosmic Fossil Record plot
            simulateFossilsAdvanced(); // Call to draw initial plot for the new module

            // Initial regime validity check
            checkRegimeValidity();


            // Initial drawing of the potential curve
            drawGravitationalMetricsAndEntropicFields();
        });
    </script>
</body>
</html>
